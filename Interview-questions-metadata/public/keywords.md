Keywords related to
[Java Keywords](#java) | [HTML Keywords](#html) | [CSS3 Keywords](#css3) | [ReactJS Keywords](#reactjs) | [AWS Keywords](#aws) | [Adobe Flex4 Keywords](#adobe-flex4) | [Team Lead Keywords](#team-lead) | [ChatGPT Keywords](#chatgpt) | [Agile Keywords](#agile) | [Spring Keywords](#spring) | [Spring Boot Keywords](#spring-boot) | [Microservice Keywords](#microservice) | [Angular Keywords](#angular) | [SQL Keywords](#sql) | [AngularJS Keywords](#angularjs) | [JavaScript Keywords](#javascript) | [Node.js Keywords](#nodejs) | [MongoDB Keywords](#mongodb) | [Spring Security Keywords](#spring-security)


[Terminologies keywords related to Kafka](#terminologies-keywords-related-to-kafka)  
[Apache Ant terminologies and buzz words](#apache-ant-terminologies-and-buzz-words)  
[Kubernetes terminologies and buzz words](#kubernetes-terminologies-and-buzz-words)  
[Docker terminologies and buzz words](#docker-terminologies-and-buzz-words)  
[Docker compose terminologies and buzz words](#docker-compose-terminologies-and-buzz-words)  
[Frontend development terminologies and buzz words](#frontend-development-terminologies-and-buzz-words)  
[Backend development terminologies and buzz words](#backend-development-terminologies-and-buzz-words)  
[Microservices terminologies and buzz words](#microservices-terminologies-and-buzz-words)  
[Mongodb terminologies and buzz words](#mongodb-terminologies-and-buzz-words)  
[MySQL terminologies and buzz words](#mysql-terminologies-and-buzz-words)  
[ETL terminologies and buzz words](#etl-terminologies-and-buzz-words)  
[AWS S3 terminologies and buzz words](#aws-s3-terminologies-and-buzz-words)  
[AWS glue terminologies and buzz words](#aws-glue-terminologies-and-buzz-words)  
[AWS glue DataBrew terminologies and buzz words](#aws-glue-databrew-terminologies-and-buzz-words)  
[Microservices design patterns terminologies and buzz words](#microservices-design-patterns-terminologies-and-buzz-words)  
[Core Java design patterns terminologies and buzz words](#core-java-design-patterns-terminologies-and-buzz-words)  
[Java 8 terminologies and buzz words](#java-8-terminologies-and-buzz-words)  
[OOPs (Object-oriented programming) concept terminologies and buzz words](#oops-object-oriented-programming-concept-terminologies-and-buzz-words)  
[Java concurrency terminologies and buzz words](#java-concurrency-terminologies-and-buzz-words)  
[JDBC terminologies and buzz words](#jdbc-terminologies-and-buzz-words)  
[JSP terminologies and buzz words](#jsp-terminologies-and-buzz-words)  
[JSTL (JavaServer Pages Standard Tag Library) terminologies and buzz words](#jstl-javaserver-pages-standard-tag-library-terminologies-and-buzz-words)  
[Servlets terminologies and buzz words](#servlets-terminologies-and-buzz-words)  
[Webpack terminologies and buzz words](#webpack-terminologies-and-buzz-words)  
[Rollup.js terminologies and buzz words](#rollupjs-terminologies-and-buzz-words)  
[Javascript terminologies and buzz words](#javascript-terminologies-and-buzz-words)  
[Reactjs terminologies and buzz words](#reactjs-terminologies-and-buzz-words)  
[Reduxjs terminologies and buzz words](#reduxjs-terminologies-and-buzz-words)  
[JWT terminologies and buzz words](#jwt-terminologies-and-buzz-words)  
[Java Annotations terminologies and buzz words](#java-annotations-terminologies-and-buzz-words)  
[Nodejs terminologies and buzz words](#nodejs-terminologies-and-buzz-words)  
[PUG (formerly known as Jade) terminologies and buzz words](#pug-formerly-known-as-jade-terminologies-and-buzz-words)  
[EJS terminologies and buzz words](#ejs-terminologies-and-buzz-words)  
[Angular terminologies and buzz words](#angular-terminologies-and-buzz-words)  
[spring boot JPA terminologies and buzz words](#spring-boot-jpa-terminologies-and-buzz-words)  
[Spring boot security terminologies and buzz words](#spring-boot-security-terminologies-and-buzz-words)  
[Maven terminologies and buzz words](#maven-terminologies-and-buzz-words)  
[Apache Ant terminologies and buzz words](#apache-ant-terminologies-and-buzz-words)  
[Gradle terminologies and buzz words](#gradle-terminologies-and-buzz-words)  

# Please write **keywords** related to:  

## java

Java, programming language, JVM, object-oriented, class, method, variable, inheritance, polymorphism, encapsulation, abstraction, syntax, platform-independent, JDK, JRE, bytecode, IDE, Eclipse, NetBeans, IntelliJ, data types, loops, conditional statements, exception handling, collections, arrays, strings, threads, GUI, Swing, JavaFX, serialization, JDBC, Spring framework.

## HTML

HTML, web development, markup language, tags, elements, attributes, structure, head, body, paragraph, heading, hyperlink, image, list, table, form, input, button, attribute, CSS, style, JavaScript, DOM, HTML5, semantic elements, div, span, attribute, responsive design, metadata, viewport, doctype, link, media, attribute, encoding, validation, W3C, browser, rendering, SEO, accessibility, semantic markup.

## css3

CSS3, Cascading Style Sheets, styling, design, selectors, properties, values, box model, layout, flexbox, grid, responsive design, media queries, transitions, animations, pseudo-classes, pseudo-elements, transforms, gradients, shadows, fonts, colors, variables, preprocessors (e.g., Sass, Less), box-sizing, normalize, vendor prefixes, browser compatibility, CSS frameworks (e.g., Bootstrap, Foundation), CSS Grid Layout, CSS Flexbox, keyframes, filters, blend modes, 3D transforms, responsive typography.

## reactjs

ReactJS, JavaScript library, front-end, UI library, component-based, virtual DOM, JSX, state, props, lifecycle methods, hooks, useState, useEffect, context API, Redux, Flux architecture, component rendering, React Router, conditional rendering, event handling, forms in React, controlled components, uncontrolled components, React Native, server-side rendering (SSR), Single Page Application (SPA), declarative programming, functional components, class components, higher-order components (HOC), PureComponent, memoization, React Fiber, reconciliation, React DevTools, JSX syntax, Babel.

## AWS

AWS, Amazon Web Services, cloud computing, EC2, S3, Lambda, IAM, VPC, RDS, DynamoDB, CloudFront, Route 53, Elastic Beanstalk, ECS, EKS, SNS, SQS, CloudWatch, CloudTrail, AWS CLI, AWS SDK, serverless architecture, API Gateway, Cognito, AWS Identity and Access Management (IAM), Security Groups, Load Balancer, Elastic Load Balancing (ELB), Auto Scaling, Elastic Container Service (ECS), Elastic Kubernetes Service (EKS), CloudFormation, AWS Lambda, Amazon Aurora, Amazon Redshift, AWS Elastic Beanstalk, AWS Direct Connect, AWS CodeDeploy, AWS CodePipeline, AWS Organizations, AWS Key Management Service (KMS), AWS Elastic File System (EFS).

## Adobe Flex4

Adobe Flex 4, Flex framework, ActionScript, MXML, Adobe Flash, Rich Internet Applications (RIAs), UI components, data binding, Spark components, Halo components, Flex SDK, Flex Compiler, Flex Builder, FlexJS, Flex Data Services, Flash Builder, Flash Player, Adobe AIR, cross-platform development, declarative programming, event-driven programming, Flex containers, ItemRenderers, States, Skinning, Flex modules, AMF (Action Message Format), BlazeDS, Flex remoting, Flex charting, Flex automation, Flex SDK open source, Flex framework architecture.

## team lead

Team lead, leadership, management, communication, delegation, mentorship, team building, project management, decision-making, problem-solving, conflict resolution, motivation, accountability, goal setting, collaboration, coaching, feedback, interpersonal skills, time management, organizational skills, strategic thinking, empowerment, Agile methodology, Scrum, task prioritization, technical leadership, decision-making, vision, adaptability, team dynamics, performance evaluation, continuous improvement.

## chatgpt

ChatGPT, GPT-3.5, OpenAI, language model, natural language processing, conversational AI, chatbot, artificial intelligence, deep learning, neural networks, transformer architecture, training data, fine-tuning, prompt engineering, natural language understanding, text generation, context-aware responses, knowledge cutoff, virtual assistant, human-like conversation, machine learning, response generation, large language model, NLP applications, language understanding, chat-based interfaces.

## Agile

Agile, Scrum, Kanban, Agile methodology, Agile principles, Sprint, User Stories, Product Backlog, Sprint Backlog, Daily Standup, Sprint Review, Sprint Retrospective, Agile Manifesto, Iterative development, Incremental development, Cross-functional teams, Product Owner, Scrum Master, Development Team, Agile ceremonies, Continuous Integration, Continuous Delivery, Burndown chart, Velocity, Lean Agile, Agile framework, Agile practices, Agile coaching, Agile transformation, Agile mindset, Adaptive planning, Customer collaboration, Responding to change, Agile tools.

## spring

Spring Framework, Java, Dependency Injection, Inversion of Control (IoC), Spring Boot, Spring MVC, Spring Data, Spring Security, Spring AOP (Aspect-Oriented Programming), Bean, ApplicationContext, Configuration, Bean Lifecycle, Spring Batch, Spring Cloud, Spring Integration, Spring REST, Hibernate, JPA (Java Persistence API), Spring JDBC, Spring Transactions, Spring Test, Spring Annotations, Spring Profiles, Spring WebFlux, Spring WebSocket, Spring Core, Spring Expression Language (SpEL), Spring AspectJ integration, Spring Boot Starter, Spring Boot Actuator, Spring Cloud Netflix, Spring Cloud Config, Spring Cloud Gateway.

## spring boot

Spring Boot, Microservices, Java, Spring Framework, Embedded Tomcat, Embedded Jetty, Embedded Undertow, Spring Boot Starter, Spring Boot Auto-Configuration, Spring Boot Actuator, Spring Boot DevTools, Spring Boot CLI, Spring Boot Data, Spring Boot Web, Spring Boot Security, Spring Boot Testing, Spring Boot RESTful API, Spring Boot JPA, Spring Boot Thymeleaf, Spring Boot Logging, Spring Boot Configuration, Spring Boot Profiles, Spring Boot Gradle, Spring Boot Maven, Spring Boot Cloud, Spring Boot Microservices Architecture, Spring Boot Docker, Spring Boot Kubernetes, Spring Boot Monitoring, Spring Boot Logging, Spring Boot Annotations.

## microservice

Microservices, Microservices Architecture, Service-oriented Architecture (SOA), Decentralized, Scalability, Resilience, Independence, Docker, Kubernetes, Containerization, RESTful API, JSON, Service Discovery, API Gateway, Circuit Breaker, Load Balancing, Event-driven, Asynchronous Communication, Message Queue, Event Sourcing, CQRS (Command Query Responsibility Segregation), Polyglot Persistence, DevOps, Continuous Integration, Continuous Deployment, Scalability, Fault Tolerance, Consistency, Micro Frontends, Spring Cloud, Service Mesh, Microservices Monitoring, Microservices Security.

## Angular

Angular, TypeScript, Single Page Application (SPA), Angular CLI, Angular Modules, Angular Components, Angular Directives, Angular Services, Dependency Injection, Angular Templates, Angular Data Binding, Two-way Binding, ngModel, Reactive Forms, Template-driven Forms, Angular Pipes, Angular Routing, Lazy Loading, Angular Lifecycle Hooks, Angular Interceptors, Angular HTTP Client, Angular Animations, Angular Material, RxJS (Reactive Extensions for JavaScript), Angular Testing, Unit Testing, Integration Testing, End-to-End Testing, Jasmine, Protractor, Angular CLI, Angular Router, Angular Dependency Injection, Angular Change Detection, Angular ngIf, ngFor, ngSwitch, Angular Decorators.

## SQL

SQL, Relational Database, Database Management System (DBMS), Structured Query Language, Tables, Columns, Rows, SQL Query, SELECT statement, FROM clause, WHERE clause, ORDER BY clause, GROUP BY clause, JOIN, INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN, Primary Key, Foreign Key, Index, Database Schema, Data Definition Language (DDL), Data Manipulation Language (DML), CREATE TABLE, ALTER TABLE, DROP TABLE, INSERT INTO, UPDATE, DELETE, Constraints, UNIQUE constraint, NOT NULL constraint, DEFAULT constraint, SQL Functions, Aggregate Functions, COUNT, SUM, AVG, MIN, MAX, Joins, Subqueries, Transactions, ACID properties.

## angularjs

AngularJS, JavaScript framework, MVC (Model-View-Controller), Data Binding, Two-way Binding, Directives, ng-app, ng-model, ng-bind, Controllers, $scope, Services, Dependency Injection, Templates, Views, Routing, $routeProvider, Directives, Custom Directives, $http service, AJAX, Promises, Filters, ng-repeat, ng-show, ng-hide, ng-if, ng-switch, Form Validation, $watch, $digest cycle, Dependency Injection, Modules, AngularJS expressions, ng-controller, ng-view, ng-app, ng-init, ng-click, ng-disabled, $rootScope, $location service.

## javascript

JavaScript, ECMAScript, Web Development, Front-end, Client-side scripting, HTML, CSS, Document Object Model (DOM), Browser, Event Handling, Functions, Variables, Data Types, Objects, Arrays, Strings, Numbers, Boolean, Operators, Control Flow, Conditional Statements, Loops, Functions, Scope, Closures, Callbacks, Promises, Asynchronous Programming, AJAX (Asynchronous JavaScript and XML), JSON (JavaScript Object Notation), ES6 (ECMAScript 2015), Arrow Functions, Template Literals, Destructuring Assignment, Classes, Modules, Promises, Fetch API, Rest and Spread Operators, Web APIs, Local Storage, Session Storage, Cookies, JavaScript Frameworks (e.g., React, Angular, Vue), Node.js, NPM (Node Package Manager), Package.json.

## Node.js

Node.js, JavaScript runtime, Server-side, Event-driven, Asynchronous, Non-blocking I/O, V8 engine, NPM (Node Package Manager), CommonJS, Modules, Express.js, RESTful API, Middleware, Routing, Template Engines (e.g., EJS, Pug), WebSocket, JSON, Callbacks, Promises, Async/Await, Streams, Buffers, File System, HTTP Module, Package.json, Nodemon, Node.js Frameworks (e.g., Express, Koa, Hapi), Node.js Libraries, MongoDB, Mongoose, MySQL, PostgreSQL, Passport.js, Authentication, Authorization, Socket.io, Serverless, AWS Lambda with Node.js, Real-time applications, Microservices with Node.js.

## mongodb

MongoDB, NoSQL database, Document-oriented, BSON (Binary JSON), Collections, Documents, Fields, JSON-like data, Document Store, CRUD Operations (Create, Read, Update, Delete), Indexing, Query Language, Aggregation Framework, Atlas (MongoDB Cloud Service), Compass (MongoDB GUI), Mongoose (MongoDB Object Modeling for Node.js), Sharding, Replication, GridFS, WiredTiger Storage Engine, Geospatial Indexing, MongoDB Drivers (e.g., Node.js driver), Capped Collections, ACID properties, NoSQL Data Model, JSON Schema, Data Consistency, Database Scalability, MongoDB Compass, MongoDB Realm, MongoDB Stitch, Document Validation, Full-text Search.

## spring security

Spring Security, Authentication, Authorization, Security Configuration, UserDetails, UserDetailsService, AuthenticationProvider, GrantedAuthority, SecurityContextHolder, AuthenticationManager, Principal, GrantedAuthority, PasswordEncoder, CSRF (Cross-Site Request Forgery) protection, Session Management, Remember-Me authentication, LDAP (Lightweight Directory Access Protocol) integration, OAuth (Open Authorization), SAML (Security Assertion Markup Language), JWT (JSON Web Token), Role-Based Access Control (RBAC), Method Security, @Secured annotation, @PreAuthorize annotation, @PostAuthorize annotation, Web Security, URL-based security, Spring Security Filters, Custom Authentication Success/Failure Handlers, Security Annotations, CSRF Token, Spring Security OAuth, Spring Security Core Module.

# Terminologies and buzz words

### Terminologies keywords related to Kafka 

Sure, here are some key terminologies and keywords related to Kafka:

1. Broker: A Kafka server responsible for handling and storing the messages.
2. Topic: A category or feed name to which messages are published by producers.
3. Producer: An application that sends messages to Kafka topics.
4. Consumer: An application that reads messages from Kafka topics.
5. Partition: A portion of a Kafka topic's data spread across multiple brokers for scalability and parallelism.
6. Offset: A unique identifier for each message within a partition.
7. ZooKeeper: A centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services.
8. Replication: The process of duplicating data across multiple brokers for fault tolerance.
9. Consumer Group: A group of consumers that jointly consume a topic. Each message is delivered to one consumer within the group.
10. Offset Management: Mechanism for tracking the last consumed message by each consumer.
11. Retention Policy: Configurable setting determining how long Kafka retains messages in a topic.
12. Kafka Connect: A framework for importing/exporting data to/from Kafka.
13. Streams: Kafka Streams is a library for building real-time, scalable, fault-tolerant, distributed applications.
14. ACL (Access Control Lists): Mechanism for controlling access to Kafka resources.
15. Log Compaction: A retention policy that retains only the latest value for each key within a Kafka topic.


### Apache Ant terminologies and buzz words

Apache Ant is a build automation tool primarily used for Java projects. Here are some key terminologies and buzzwords associated with Apache Ant:

1. **Build Script:** A build script is an XML file that defines the tasks and targets required to build, test, and deploy a project using Ant. It typically has a filename like `build.xml` and is structured using XML tags.

2. **Task:** A task is a unit of work defined in the build script. Ant provides a wide range of built-in tasks for compiling code, copying files, running tests, generating documentation, and more. Tasks can also be extended or customized using custom Java classes.

3. **Target:** A target is a collection of tasks that are executed together as a single unit. Targets are defined in the build script and can depend on other targets, allowing for a modular and organized build process.

4. **Dependency:** Dependencies are relationships between targets that specify the order in which targets should be executed. Targets can depend on other targets, ensuring that prerequisite tasks are completed before executing dependent tasks.

5. **Property:** Properties are key-value pairs used to store configuration settings, file paths, version numbers, and other values used in the build process. Properties can be defined in the build script, passed as command-line arguments, or loaded from external files.

6. **Macrodef:** A macrodef is a custom task definition that encapsulates a sequence of tasks into a reusable unit. Macros allow developers to define complex workflows once and reuse them multiple times throughout the build script.

7. **Build Lifecycle:** The build lifecycle refers to the sequence of steps involved in building, testing, and deploying a project. It typically includes tasks such as compiling source code, running tests, generating documentation, packaging artifacts, and deploying to production.

8. **Integration with IDEs:** Ant can be integrated with Integrated Development Environments (IDEs) such as Eclipse, IntelliJ IDEA, and NetBeans to provide visual editing, debugging, and execution of Ant build scripts within the IDE environment.

9. **External Tools Integration:** Ant can be integrated with external tools and libraries such as JUnit for unit testing, Ivy for dependency management, FindBugs for static code analysis, and more. These integrations enhance the capabilities of Ant and facilitate the automation of various development tasks.

10. **Community and Extensions:** Apache Ant has a vibrant community of users and contributors who develop and share extensions, plugins, and best practices for using Ant in different scenarios. These extensions expand the functionality of Ant and address specific requirements in various domains.

By understanding these terminologies and concepts, developers can effectively leverage Apache Ant to automate the build process and streamline software development workflows.

### Kubernetes terminologies and buzz words

Sure, Kubernetes has quite a few terminologies and buzzwords. Here are some of the key ones:

1. **Pod**: The smallest deployable unit in Kubernetes, consisting of one or more containers.

2. **Node**: A physical or virtual machine in the Kubernetes cluster where pods are deployed.

3. **Deployment**: A Kubernetes resource that manages the lifecycle of pods and replica sets.

4. **Service**: An abstraction that defines a logical set of pods and a policy by which to access them.

5. **ReplicaSet**: Ensures that a specified number of pod replicas are running at any given time.

6. **Namespace**: A way to divide cluster resources between multiple users or teams.

7. **Container**: A lightweight, portable, and self-sufficient software package that contains everything needed to run an application.

8. **Cluster**: A set of physical or virtual machines that run containerized applications managed by Kubernetes.

9. **Label**: A key-value pair attached to Kubernetes objects for grouping and selecting related resources.

10. **Ingress**: A Kubernetes resource that manages external access to services within a cluster.

11. **PersistentVolume**: A piece of storage in the cluster that has been provisioned by an administrator.

12. **Secret**: A Kubernetes resource used to store sensitive information, such as passwords, OAuth tokens, and SSH keys.

13. **ConfigMap**: A Kubernetes resource used to store configuration data separately from the pod's specification.

14. **HorizontalPodAutoscaler (HPA)**: Automatically adjusts the number of replicas in a deployment based on CPU utilization or custom metrics.

15. **StatefulSet**: Manages stateful applications and maintains a unique identity for each pod.

These are just a few, but there are many more depending on the specific use cases and configurations within a Kubernetes environment.


### Docker terminologies and buzz words

Certainly! Docker has its own set of terminologies and buzzwords. Here are some of the key ones:

1. **Image**: A lightweight, standalone, executable package that includes everything needed to run a piece of software, including the code, runtime, libraries, environment variables, and configuration files.

2. **Container**: An instance of a Docker image that runs a software application in an isolated environment.

3. **Dockerfile**: A text file that contains instructions for building a Docker image.

4. **Docker Engine**: The core software component of Docker that runs and manages containers.

5. **Registry**: A storage and distribution system for Docker images. Docker Hub is the default public registry.

6. **Containerization**: The process of encapsulating an application and its dependencies into a container image.

7. **Volume**: A Docker feature that allows data to persist beyond the lifetime of a container.

8. **Docker Compose**: A tool for defining and running multi-container Docker applications using a YAML file.

9. **Docker Swarm**: A native clustering and orchestration tool for Docker containers.

10. **Docker Hub**: A cloud-based repository where Docker users can share and distribute container images.

11. **Docker Network**: A networking feature of Docker that allows containers to communicate with each other and with external networks.

12. **Docker Registry**: A service that stores Docker images for distribution and sharing within a network or organization.

13. **Overlay Network**: A Docker networking feature that enables communication between containers running on different Docker hosts.

14. **Docker Volume Driver**: A plugin system that allows Docker containers to use external storage devices.

15. **Docker Machine**: A tool that provisions Docker hosts on local or remote machines.

These are some of the fundamental terms and concepts in the Docker ecosystem. There are many more advanced features and tools available, but these should give you a good starting point.




### Docker compose terminologies and buzz words

Certainly! Docker Compose introduces its own set of terminologies and concepts for defining and running multi-container Docker applications. Here are some key terms:

1. **Service**: A containerized application defined in a Docker Compose file. Each service represents a container and its configuration.

2. **Docker Compose file**: A YAML file (usually named `docker-compose.yml`) that defines the structure of multi-container Docker applications, including services, networks, volumes, and other configurations.

3. **Container**: An isolated environment that runs a software application and its dependencies, managed by Docker.

4. **Image**: A read-only template used to create Docker containers. Images are defined in the Docker Compose file and are built from Dockerfiles or pulled from Docker registries.

5. **Volume**: A Docker feature that allows data to persist beyond the lifetime of a container. Volumes can be defined in the Docker Compose file to share data between containers or persist data on the host machine.

6. **Network**: A communication channel that allows containers within the same Docker Compose application to communicate with each other. Networks can be defined in the Docker Compose file to isolate containers or provide connectivity between them.

7. **Environment variables**: Variables that are injected into Docker containers at runtime, allowing dynamic configuration of containerized applications. Environment variables can be defined in the Docker Compose file or passed externally.

8. **Build context**: The directory containing the files needed to build a Docker image. The build context is specified in the Docker Compose file and is used when building custom Docker images.

9. **Port mapping**: The process of mapping ports between containers and the host machine, allowing external access to containerized services. Port mappings can be defined in the Docker Compose file to expose container ports to the host machine.

10. **Dependency**: The relationship between services in a Docker Compose application, where one service depends on another for functionality. Dependencies can be defined in the Docker Compose file to ensure services start in the correct order.

These are some of the key terms and concepts in Docker Compose. Understanding them will help you define, manage, and run multi-container Docker applications efficiently using Docker Compose.



### Frontend development terminologies and buzz words

Frontend development has its own set of terminologies and buzzwords. Here are some key ones:

1. **HTML (Hypertext Markup Language)**: The standard markup language for creating web pages and web applications.

2. **CSS (Cascading Style Sheets)**: A style sheet language used for describing the presentation of a document written in HTML.

3. **JavaScript**: A programming language that enables interactive and dynamic content on web pages. 

4. **Responsive Design**: Design approach aimed at creating websites that provide optimal viewing and interaction experience across a wide range of devices and screen sizes.

5. **CSS Frameworks**: Pre-designed libraries that provide standardized styling and layout for web pages and web applications.

6. **JavaScript Frameworks/Libraries**: Tools like React, Angular, or Vue.js that provide a structured way to build interactive user interfaces and manage application state.

7. **API (Application Programming Interface)**: A set of rules and protocols that allows different software applications to communicate with each other.

8. **AJAX (Asynchronous JavaScript and XML)**: A technique used to send and receive data from a server asynchronously without interfering with the display and behavior of the existing page.

9. **Single Page Application (SPA)**: A web application that loads a single HTML page and dynamically updates the content as the user interacts with the application.

10. **Frontend Frameworks**: Comprehensive libraries and tools that provide a structure and predefined components for building web applications, such as Bootstrap, Materialize, or Foundation.

11. **UI (User Interface)**: The visual elements and layout of a web page or application that users interact with.

12. **UX (User Experience)**: The overall experience of a user when interacting with a web page or application, including usability, accessibility, and satisfaction.

13. **DOM (Document Object Model)**: A programming interface for web documents that represents the structure of a document as a tree of objects, allowing scripts to dynamically access and modify content.

14. **Component-based Development**: A development approach where UIs are built from reusable and self-contained components, promoting code reusability and maintainability.

15. **Progressive Web Apps (PWA)**: Web applications that use modern web capabilities to provide a native app-like experience, including offline functionality, push notifications, and home screen installation.

These are just a few of the many terms and concepts in frontend development. Keeping up with these terminologies can help you navigate and stay informed in the dynamic world of web development.



### Backend development terminologies and buzz words

Certainly! Backend development has its own set of terminologies and buzzwords. Here are some key ones:

1. **Server**: A computer or system that provides resources, data, services, or functionality to other computers, known as clients, over a network.

2. **Database**: A structured set of data stored electronically in a computer system, typically organized in tables, rows, and columns, and used for storing, retrieving, and managing data.

3. **API (Application Programming Interface)**: A set of rules, protocols, and tools that allows different software applications to communicate with each other.

4. **RESTful API (Representational State Transfer)**: An architectural style for designing networked applications, typically using HTTP requests to perform CRUD (Create, Read, Update, Delete) operations on resources.

5. **Microservices**: A software architectural style that structures an application as a collection of loosely coupled services, each responsible for a specific business function and communicating with each other via APIs.

6. **Framework**: A software framework that provides a foundation of reusable code libraries, tools, and APIs for developing software applications.

7. **Server-side scripting**: The process of writing code that runs on the server to generate dynamic web content or perform server-side tasks, often using languages like PHP, Python, Ruby, or Node.js.

8. **Authentication**: The process of verifying the identity of a user or system, typically through the use of usernames, passwords, tokens, or other credentials.

9. **Authorization**: The process of determining what actions a user or system is allowed to perform, typically based on their identity, role, or permissions.

10. **Middleware**: Software components that provide common services and capabilities to applications, often used in the context of web development for tasks like request processing, authentication, logging, and caching.

11. **Scalability**: The ability of a system to handle increasing amounts of work or traffic by adding resources, such as CPU, memory, or storage, without significantly affecting performance.

12. **Caching**: The process of storing frequently accessed data in memory or on disk to reduce the need to recompute or retrieve it from the original source, improving performance and scalability.

13. **Session Management**: The process of maintaining stateful information about a user's interaction with a web application across multiple requests, typically using cookies, session tokens, or other mechanisms.

14. **ORM (Object-Relational Mapping)**: A programming technique that allows developers to interact with a relational database using an object-oriented paradigm, mapping database tables to classes and rows to objects.

15. **CI/CD (Continuous Integration/Continuous Deployment)**: A set of practices and tools used to automate the process of integrating code changes into a shared repository, testing them, and deploying them to production environments.

These are just a few of the many terms and concepts in backend development. Keeping up with these terminologies can help you navigate and stay informed in the dynamic world of software development.



### Microservices terminologies and buzz words

Microservices architecture comes with its own set of terminologies and buzzwords. Here are some key ones:

1. **Microservices**: A software architectural style that structures an application as a collection of loosely coupled services, each responsible for a specific business function and communicating with each other via APIs.

2. **Service**: An individual component or module of functionality within a microservices architecture, typically encapsulating a specific business capability.

3. **API (Application Programming Interface)**: A set of rules, protocols, and tools that allows different software components or services to communicate with each other.

4. **Containerization**: The process of packaging software applications along with their dependencies into lightweight, portable containers, such as Docker containers, for easy deployment and scalability.

5. **Orchestration**: The automated management and coordination of microservices, containers, and other resources within a distributed system, typically performed by orchestration tools like Kubernetes, Docker Swarm, or Apache Mesos.

6. **Service Discovery**: The process of dynamically locating and connecting to available services within a microservices architecture, often facilitated by service registry and discovery tools like Consul, Etcd, or ZooKeeper.

7. **Event-driven Architecture**: A software architectural pattern where components or services communicate with each other by producing and consuming events, enabling loose coupling and asynchronous communication.

8. **Saga Pattern**: A design pattern for managing distributed transactions across multiple microservices, ensuring consistency and data integrity despite the distributed nature of the system.

9. **Circuit Breaker**: A design pattern used to prevent cascading failures in a microservices architecture by detecting and isolating failures in dependent services.

10. **Fault Tolerance**: The ability of a system to continue operating and providing functionality in the presence of failures or errors, often achieved through redundancy, error handling, and graceful degradation mechanisms.

11. **Service Mesh**: A dedicated infrastructure layer for handling communication between microservices, providing features like service discovery, load balancing, security, and observability.

12. **Container Orchestration**: The automated management and deployment of containers within a distributed environment, often performed by container orchestration platforms like Kubernetes, Docker Swarm, or Amazon ECS.

13. **DevOps**: A set of practices and cultural philosophies that aims to unify software development (Dev) and IT operations (Ops) to enable continuous delivery, collaboration, and automation throughout the software development lifecycle.

14. **Observability**: The ability to measure, monitor, and understand the internal state and behavior of a system, including metrics, logs, and traces, often facilitated by observability tools like Prometheus, Grafana, or Jaeger.

15. **Serverless Computing**: A cloud computing model where cloud providers dynamically manage the allocation and scaling of resources, allowing developers to focus on writing code without worrying about infrastructure management.

These are just a few of the many terms and concepts in microservices architecture. Keeping up with these terminologies can help you navigate and stay informed in the dynamic world of distributed systems and software development.


### Mongodb terminologies and buzz words

Certainly! MongoDB, being a popular NoSQL database, has its own set of terminologies and buzzwords. Here are some key ones:

1. **Document**: In MongoDB, data is stored in flexible, JSON-like documents. Each document can have a different structure, which allows for greater flexibility compared to traditional relational databases.

2. **Collection**: A grouping of MongoDB documents. Collections are analogous to tables in relational databases but do not enforce a schema. Documents within a collection can have different fields.

3. **Database**: A physical container for collections. Each MongoDB instance can have multiple databases, each containing its own set of collections.

4. **Document-oriented database**: MongoDB is a document-oriented database, meaning it stores data in documents rather than rows and columns. This allows for more natural representation of data structures.

5. **Index**: An index in MongoDB is similar to indexes in relational databases. It improves the speed of data retrieval operations by allowing queries to quickly locate documents based on indexed fields.

6. **Query**: In MongoDB, queries are used to retrieve data from collections based on specified criteria. MongoDB supports a rich query language that includes filtering, projection, sorting, and aggregation.

7. **Aggregation**: Aggregation operations in MongoDB allow for data processing and transformation, such as grouping, sorting, and performing calculations on data within collections.

8. **Sharding**: Sharding is a method of horizontal partitioning in MongoDB, where data is distributed across multiple machines to improve scalability and performance.

9. **Replica Set**: A group of MongoDB servers that maintain the same data set, providing redundancy and high availability. Replica sets are used for automatic failover and data redundancy.

10. **GridFS**: GridFS is a specification for storing and retrieving large files in MongoDB. It breaks files into smaller chunks, which are then stored as separate documents, allowing for efficient storage and retrieval of large files.

11. **Read Concern**: Read concern in MongoDB specifies the level of consistency guarantee for read operations. It allows users to control the visibility of data changes across distributed environments.

12. **Write Concern**: Write concern in MongoDB specifies the level of acknowledgment required from MongoDB servers for write operations. It determines the durability of data changes and ensures data consistency.

13. **Geospatial Indexes**: MongoDB supports geospatial indexes, allowing for efficient querying of location-based data. This is useful for applications that require location-aware features, such as geolocation services or mapping applications.

14. **Change Streams**: Change streams in MongoDB provide a way to watch for changes in collections in real-time. They allow applications to react to data changes as they occur, enabling reactive and event-driven architectures.

15. **Atlas**: MongoDB Atlas is a fully managed cloud database service provided by MongoDB, Inc. It allows users to deploy, operate, and scale MongoDB clusters with ease, without the need for manual intervention.

These are some of the key terminologies and concepts in MongoDB. Understanding them can help you work effectively with MongoDB databases and develop scalable and efficient applications.


### MySQL terminologies and buzz words

Certainly! MySQL, being one of the most popular relational database management systems, has its own set of terminologies and buzzwords. Here are some key ones:

1. **Database**: A structured set of data organized and stored electronically in a computer system. MySQL databases consist of one or more tables and are used to store and manage data.

2. **Table**: A collection of related data organized into rows and columns. Tables are the fundamental storage unit in MySQL databases.

3. **Row**: A single record or entry in a MySQL table, containing a set of values corresponding to the columns defined in the table.

4. **Column**: A vertical arrangement of data elements in a MySQL table, representing a particular attribute or field of the data.

5. **Primary Key**: A unique identifier for each row in a MySQL table, used to ensure data integrity and facilitate efficient data retrieval.

6. **Foreign Key**: A field in a MySQL table that establishes a relationship with another table's primary key, enforcing referential integrity between related tables.

7. **Index**: A data structure that improves the speed of data retrieval operations in MySQL by allowing queries to quickly locate rows based on indexed columns.

8. **Query**: A request for data or information from a MySQL database. Queries are written in SQL (Structured Query Language) and can perform various operations such as selecting, inserting, updating, or deleting data.

9. **Stored Procedure**: A precompiled collection of SQL statements stored in the MySQL database and executed as a single unit. Stored procedures can accept input parameters and return results to the caller.

10. **Trigger**: A database object in MySQL that automatically executes a set of SQL statements in response to certain events, such as insertions, updates, or deletions on a table.

11. **Normalization**: The process of organizing data in MySQL databases to reduce redundancy and improve data integrity by eliminating data anomalies.

12. **Denormalization**: The opposite of normalization, denormalization in MySQL involves intentionally introducing redundancy into the database schema to improve query performance by reducing the need for joins and increasing data availability.

13. **Transaction**: A sequence of one or more SQL statements executed as a single unit of work in MySQL. Transactions ensure data consistency by either committing all changes or rolling back to the original state in case of failure.

14. **ACID Properties**: A set of properties that guarantee reliable and consistent database transactions. ACID stands for Atomicity, Consistency, Isolation, and Durability.

15. **InnoDB**: The default storage engine for MySQL, known for its support for transactions, referential integrity, and crash recovery features.

These are some of the key terminologies and concepts in MySQL. Understanding them can help you work effectively with MySQL databases and develop robust and efficient applications.


### ETL terminologies and buzz words

ETL (Extract, Transform, Load) is a process used in data warehousing and analytics to extract data from various sources, transform it into a consistent format, and load it into a target database or data warehouse. Here are some key terminologies and buzzwords associated with ETL:

1. **Extract**: The process of retrieving data from one or more source systems, which can include databases, files, APIs, or other data repositories.

2. **Transform**: The process of cleaning, structuring, and manipulating the extracted data to make it suitable for analysis or storage in the target system. Transformation tasks may include data cleansing, data validation, aggregation, normalization, or enrichment.

3. **Load**: The process of inserting the transformed data into the target database or data warehouse. Loading may involve inserting new records, updating existing records, or appending data to existing tables.

4. **Data Warehouse**: A centralized repository that stores structured, historical data from one or more sources, typically used for reporting, analysis, and decision-making purposes.

5. **Data Mart**: A subset of a data warehouse that is optimized for a specific business function, department, or group of users. Data marts often contain summarized or aggregated data tailored to the needs of specific users or applications.

6. **ETL Pipeline**: A series of interconnected processes and tasks that automate the extraction, transformation, and loading of data from source systems to target databases or data warehouses.

7. **Batch Processing**: A method of processing data in which data is collected, processed, and loaded in discrete batches or chunks at scheduled intervals, often overnight or during off-peak hours.

8. **Real-time ETL**: A variant of ETL in which data is extracted, transformed, and loaded into the target system in near real-time or with minimal latency, enabling organizations to make timely decisions based on up-to-date data.

9. **Data Integration**: The process of combining data from different sources into a unified view, often involving ETL processes to transform and load data into a centralized repository.

10. **Data Cleansing**: The process of detecting and correcting errors, inconsistencies, and duplicates in the data during the transformation phase of ETL, ensuring data quality and integrity.

11. **Data Mapping**: The process of defining the relationships and transformations between data elements in the source and target systems, specifying how data should be mapped, transformed, and loaded.

12. **Data Profiling**: The process of analyzing and understanding the structure, quality, and characteristics of the data in the source systems, often used to identify data quality issues and inform data transformation rules.

13. **ETL Tool**: Software tools and platforms specifically designed to automate and streamline the ETL process, providing features such as data extraction, transformation, loading, scheduling, monitoring, and error handling.

14. **Change Data Capture (CDC)**: A technique used to identify and capture changes made to source data since the last ETL run, enabling incremental updates and real-time replication of data to the target system.

15. **Data Quality**: The measure of the accuracy, completeness, consistency, timeliness, and reliability of the data, ensuring that data meets the requirements of the intended use case or business process.

These are some of the key terminologies and concepts in ETL. Understanding them can help you design, implement, and maintain efficient data integration processes in your organization.

### AWS S3 terminologies and buzz words

Certainly! Amazon Simple Storage Service (S3) is a widely used object storage service provided by Amazon Web Services (AWS). Here are some key terminologies and buzzwords associated with AWS S3:

1. **Bucket**: A container for storing objects in S3. All objects are stored within a bucket, and each bucket has a unique name across all of AWS.

2. **Object**: The fundamental entity stored in S3, which consists of data (such as a file) and metadata (information about the object). Objects can range in size from 0 bytes to 5 terabytes.

3. **Key**: The unique identifier for an object within a bucket. It is similar to a file name and includes the full path of the object within the bucket.

4. **Region**: A geographical area where S3 stores data. Each bucket is associated with a specific AWS region, and data is replicated across multiple Availability Zones within the region for durability and availability.

5. **Storage Classes**: Different storage tiers offered by S3, each optimized for specific use cases based on performance, durability, availability, and cost. Common storage classes include S3 Standard, S3 Standard-IA (Infrequent Access), S3 One Zone-IA, S3 Glacier, and S3 Glacier Deep Archive.

6. **Lifecycle Policies**: Rules defined at the bucket or object level to automatically transition objects between different storage classes or delete them after a specified period. Lifecycle policies help optimize storage costs by moving data to lower-cost tiers as it ages.

7. **Versioning**: A feature of S3 that allows multiple versions of an object to be stored in the same bucket. Versioning helps protect against accidental deletion or overwrite of objects and enables data recovery in case of unintended changes.

8. **Cross-Region Replication (CRR)**: A feature of S3 that automatically replicates objects from one bucket to another in a different AWS region. CRR helps improve data durability and availability by maintaining copies of objects in multiple geographic locations.

9. **Transfer Acceleration**: A feature of S3 that uses Amazon CloudFront's globally distributed edge locations to accelerate data transfers to and from S3. Transfer Acceleration can significantly reduce latency and improve upload speeds, especially for users located far from the AWS region hosting the bucket.

10. **Event Notifications**: A feature of S3 that allows you to configure event notifications for specific bucket events, such as object creation, deletion, or replication. Event notifications can trigger AWS Lambda functions, Amazon SNS notifications, or Amazon SQS messages, enabling automated workflows and integrations with other AWS services.

11. **Access Control Lists (ACLs)**: A mechanism for managing access to objects and buckets in S3. ACLs define who can perform specific actions (such as read, write, or delete) on objects or buckets and can be configured at the bucket or object level.

12. **Bucket Policies**: JSON-based access policies that define permissions for a bucket and its objects. Bucket policies can grant or deny access based on various criteria, such as IP address, IAM user, or AWS account, and are applied to all objects within the bucket.

13. **Static Website Hosting**: A feature of S3 that allows you to host static websites directly from an S3 bucket. You can configure S3 to serve static content (HTML, CSS, JavaScript, etc.) over HTTP or HTTPS, with support for custom domain names and error pages.

14. **Server-Side Encryption**: A feature of S3 that automatically encrypts objects at rest using AES-256 encryption. You can choose between different encryption options, including SSE-S3 (encryption by AWS) or SSE-KMS (encryption with AWS Key Management Service).

15. **Data Transfer Costs**: The costs associated with transferring data into and out of S3, including data transfer within the same AWS region, data transfer between AWS regions, and data transfer over the internet.

These are some of the key terminologies and concepts in AWS S3. Understanding them can help you effectively use S3 for storing, managing, and serving your data in the AWS cloud.

### AWS glue terminologies and buzz words

AWS Glue is a fully managed extract, transform, and load (ETL) service provided by Amazon Web Services (AWS). Here are some key terminologies and buzzwords associated with AWS Glue:

1. **ETL**: Extract, Transform, Load - The process of extracting data from various sources, transforming it into a consistent format, and loading it into a target data store for analysis or reporting.

2. **Data Catalog**: A central metadata repository in AWS Glue that stores information about datasets, tables, schemas, partitions, and transformations. The data catalog provides a unified view of data across different sources and formats.

3. **Crawler**: An AWS Glue component that automatically scans and discovers data in various data stores, such as Amazon S3, RDS, Redshift, and DynamoDB. Crawlers infer schema, partitioning, and data statistics to populate the AWS Glue Data Catalog.

4. **Job**: An AWS Glue component that defines an ETL workflow, including the source data, transformation logic, and target data destination. Jobs can be authored using Python or Apache Spark code and run on a scheduled or ad-hoc basis.

5. **Trigger**: A mechanism in AWS Glue that enables you to automatically start an ETL job based on a predefined event or schedule. Triggers can be configured to start jobs in response to data arriving in S3, CloudWatch events, or on a recurring schedule.

6. **Development Endpoint**: A provisioned environment in AWS Glue that allows developers to interactively author, debug, and test ETL scripts using the AWS Glue console or external development tools. Development endpoints provide an isolated environment for experimenting with data and code.

7. **Data Lake**: A centralized repository that stores structured and unstructured data at scale, typically in a raw or unprocessed form. AWS Glue can be used to transform and catalog data stored in a data lake, enabling analytics and data exploration.

8. **Schema**: A formal definition of the structure of a dataset or table, including the names, types, and relationships of its fields or columns. AWS Glue uses schemas to infer the structure of data during discovery and transformation processes.

9. **Partition**: A way to logically divide data into smaller, manageable subsets based on a partitioning key, such as date, region, or category. Partitions are commonly used to improve query performance and reduce data scanning in large datasets.

10. **Data Lake House**: An architectural approach that combines the flexibility and scalability of a data lake with the performance and reliability of a data warehouse. AWS Glue can be used to build and maintain data lake house solutions by transforming and preparing data for analytics and reporting.

11. **Apache Spark**: A fast and general-purpose distributed computing system for big data processing, often used for large-scale data processing, machine learning, and ETL workflows. AWS Glue supports Apache Spark as a runtime environment for running ETL jobs.

12. **AWS Lambda**: A serverless compute service provided by AWS that allows you to run code in response to events without provisioning or managing servers. AWS Glue can invoke AWS Lambda functions to perform custom data processing tasks as part of ETL workflows.

13. **Glue DataBrew**: An AWS service that provides visual data preparation tools for cleaning, transforming, and normalizing data without writing code. Glue DataBrew can be integrated with AWS Glue to simplify and accelerate data preparation tasks.

14. **Data Lineage**: The ability to track and visualize the movement and transformation of data across different systems and processes. AWS Glue provides data lineage capabilities to trace data from its source to its destination, helping to ensure data quality and compliance.

15. **Data Quality**: The measure of the accuracy, completeness, consistency, timeliness, and reliability of data. AWS Glue provides data quality assessment capabilities to identify and remediate data quality issues during ETL processes.

These are some of the key terminologies and concepts in AWS Glue. Understanding them can help you effectively use AWS Glue to build, automate, and manage ETL workflows in the AWS cloud.


### AWS glue DataBrew terminologies and buzz words

AWS Glue DataBrew is a visual data preparation tool that simplifies the process of cleaning and transforming data for analytics and machine learning. Here are some key terminologies and buzzwords associated with AWS Glue DataBrew:

1. **Dataset**: A collection of data that is ingested and processed by AWS Glue DataBrew. Datasets can be sourced from various locations, such as Amazon S3, Amazon Redshift, or relational databases.

2. **Project**: A workspace within AWS Glue DataBrew where users can create and manage data preparation tasks for a specific dataset. Projects provide a centralized location for organizing and collaborating on data preparation activities.

3. **Recipe**: A set of data transformation steps defined in AWS Glue DataBrew to clean, enrich, and normalize data. Recipes are created using a visual interface and can include operations such as filtering, joining, pivoting, and formatting.

4. **Profile**: A summary of statistical information and data quality metrics generated by AWS Glue DataBrew for a dataset or recipe. Profiles provide insights into the structure, distribution, and quality of the data, helping users identify issues and make informed decisions.

5. **Data Quality Rule**: A predefined or custom rule applied to data in AWS Glue DataBrew to detect and flag anomalies, errors, or inconsistencies. Data quality rules help ensure the accuracy and integrity of data during the preparation process.

6. **Sample Data**: A subset of data from a dataset used for exploratory analysis and testing in AWS Glue DataBrew. Sample data allows users to preview and interact with a portion of the dataset before applying transformations.

7. **Data Transformation**: The process of converting raw data into a structured and usable format for analysis or machine learning. AWS Glue DataBrew provides a variety of built-in transformations and functions for cleaning, enriching, and aggregating data.

8. **Data Profiling**: The process of analyzing and summarizing the characteristics and quality of data in AWS Glue DataBrew. Data profiling helps users understand the distribution, patterns, and anomalies present in the data, facilitating data preparation and decision-making.

9. **Data Cleansing**: The process of identifying and correcting errors, duplicates, and inconsistencies in data to improve its quality and reliability. AWS Glue DataBrew offers tools and functions for cleansing and standardizing data, such as removing duplicates, correcting typos, and parsing dates.

10. **Data Enrichment**: The process of enhancing raw data with additional information or context to make it more valuable for analysis or machine learning. AWS Glue DataBrew supports data enrichment through operations such as joining datasets, applying lookups, and deriving new attributes.

11. **Data Visualization**: The presentation of data in visual formats, such as charts, graphs, and tables, to facilitate understanding and analysis. While AWS Glue DataBrew focuses primarily on data preparation, it integrates with other AWS services, such as Amazon QuickSight, for data visualization and exploration.

12. **Data Catalog Integration**: The seamless integration of AWS Glue DataBrew with the AWS Glue Data Catalog, allowing users to access and prepare data stored in various data sources, including Amazon S3, Amazon Redshift, and relational databases.

13. **Data Lineage**: The tracking and visualization of the lineage or lineage of data in AWS Glue DataBrew, showing how data is ingested, prepared, and consumed across different stages of the data pipeline. Data lineage helps users understand the origin and impact of changes to data.

14. **Collaboration**: The ability for multiple users to work together on data preparation tasks within AWS Glue DataBrew. Collaboration features include sharing projects, recipes, and datasets, as well as providing comments and feedback on data transformations.

15. **Scheduled Jobs**: The automated execution of data preparation tasks on a recurring basis in AWS Glue DataBrew. Scheduled jobs allow users to define a schedule for running recipes and updating datasets, ensuring data remains up-to-date and ready for analysis.

These are some of the key terminologies and concepts in AWS Glue DataBrew. Understanding them can help you effectively use the tool to prepare, clean, and transform data for analytics and machine learning workflows.


### Microservices design patterns terminologies and buzz words

Certainly! Microservices architecture comes with various design patterns and best practices to address common challenges and requirements. Here are some key terminologies and buzzwords associated with microservices design patterns:

1. **Service Decomposition**: The process of breaking down a monolithic application into smaller, independent services, each responsible for a specific business capability or domain.

2. **Service Autonomy**: The principle that each microservice should be self-contained and independently deployable, with its own data store and business logic.

3. **Service Discovery**: The mechanism by which microservices locate and communicate with each other in a distributed environment. Service discovery can be achieved through service registries, DNS-based solutions, or third-party tools.

4. **API Gateway**: A service that sits at the entry point of a microservices architecture and acts as a single entry point for client applications to access multiple microservices. API gateways handle routing, authentication, authorization, and protocol translation.

5. **Event Sourcing**: A pattern where microservices communicate and collaborate by producing and consuming events. Events represent state changes or domain events that are recorded and used for updating data in other microservices asynchronously.

6. **CQRS (Command Query Responsibility Segregation)**: A pattern that separates the responsibility for handling commands (write operations) from queries (read operations) in a microservices architecture. CQRS helps improve scalability, performance, and maintainability by optimizing read and write operations independently.

7. **Saga Pattern**: A design pattern for managing distributed transactions across multiple microservices. Sagas coordinate a series of local transactions within each microservice and use compensating transactions to ensure eventual consistency across the entire system.

8. **Service Mesh**: A dedicated infrastructure layer for handling communication between microservices, providing features such as service discovery, load balancing, encryption, and observability. Service meshes use sidecar proxies to intercept and manage traffic between microservices.

9. **Bulkhead Pattern**: A pattern that isolates and limits the impact of failures in one microservice from affecting other microservices. Bulkheads enforce resource constraints, such as thread pools or connection pools, to prevent cascading failures and improve system resilience.

10. **Retry Pattern**: A pattern that automatically retries failed requests or operations in microservices to improve fault tolerance and resilience. Retries can be implemented with exponential backoff, circuit breakers, or retry queues to handle transient failures.

11. **Circuit Breaker Pattern**: A pattern that detects and prevents repeated failures in microservices by temporarily interrupting requests to a failing service. Circuit breakers monitor service health and open when failure thresholds are exceeded, reducing the impact of failures on downstream services.

12. **Backpressure Pattern**: A pattern that controls the rate of data flow or requests in microservices to prevent overload and resource exhaustion. Backpressure mechanisms, such as queueing, throttling, or load shedding, help manage system capacity and prioritize critical workloads.

13. **Service Orchestration vs. Choreography**: Two approaches to coordinating interactions between microservices. Service orchestration involves a central coordinator that controls and sequences interactions between services, while choreography relies on decentralized communication and collaboration between services.

14. **Immutable Infrastructure**: A principle that advocates for treating infrastructure as code and deploying immutable, disposable components, such as containers or virtual machines, to ensure consistency, reproducibility, and scalability in microservices environments.

15. **Observability**: The ability to monitor, measure, and understand the internal state and behavior of microservices in real-time. Observability tools provide metrics, logs, and traces to diagnose issues, optimize performance, and improve reliability in microservices architectures.

These are just a few of the many design patterns and concepts used in microservices architecture. Understanding these patterns can help architects and developers design scalable, resilient, and maintainable microservices-based systems.

Of course! Here are some additional terminologies and buzzwords related to microservices architecture:

16. **Domain-Driven Design (DDD)**: An approach to software development that emphasizes modeling the domain of a problem space and designing software systems around it. DDD aligns well with microservices architecture by encouraging the creation of services that reflect specific business domains.

17. **Event-Driven Architecture (EDA)**: An architectural style in which components communicate with each other by producing and consuming events. Event-driven architecture is often used in microservices to enable loose coupling, scalability, and asynchronous communication between services.

18. **Service-Level Objective (SLO)**: A quantitative measure of the desired reliability or performance of a microservice, expressed as a target value for a specific metric (e.g., availability, latency). SLOs help define service expectations and guide resource allocation and optimization efforts.

19. **Service-Level Agreement (SLA)**: A contractual agreement between service providers and consumers that defines the expected level of service, including guarantees for availability, performance, and support. SLAs establish accountability and provide recourse in case of service failures.

20. **Blue-Green Deployment**: A deployment strategy in which two identical environments, referred to as blue and green, are maintained concurrently. Updates or changes are first deployed to the inactive environment (e.g., green), which is then swapped with the active environment (e.g., blue) once the update is validated. Blue-green deployments minimize downtime and risk by enabling seamless rollbacks in case of issues.

21. **Canary Deployment**: A deployment strategy that gradually rolls out changes to a small subset of users or traffic before making them available to the entire user base. Canary deployments allow for early validation of changes and mitigate the impact of potential issues by limiting exposure.

22. **API Versioning**: The practice of managing changes to APIs by assigning version numbers to each release or iteration. API versioning ensures backward compatibility and allows clients to choose which version of the API to use, minimizing disruption and enabling controlled evolution of the API over time.

23. **Serverless Architecture**: An architectural style in which applications are built and run without managing server infrastructure. Serverless architectures leverage cloud services, such as AWS Lambda, to execute code on-demand, scale automatically, and pay only for the resources consumed.

24. **Micro Frontends**: An architectural pattern for decomposing user interfaces into small, independently deployable frontend components, each owned by a separate team. Micro frontends enable teams to develop, deploy, and evolve frontend features autonomously, similar to microservices for backend functionality.

25. **DevOps**: A cultural and organizational approach that emphasizes collaboration, automation, and continuous integration and delivery (CI/CD) between development and operations teams. DevOps practices aim to streamline software delivery, improve agility, and increase the quality and reliability of software systems.

26. **Immutable Infrastructure**: A concept in which infrastructure components, such as servers or containers, are treated as immutable artifacts that are never modified after deployment. Immutable infrastructure ensures consistency, reproducibility, and reliability by avoiding configuration drift and minimizing manual intervention.

27. **Chaos Engineering**: A discipline that involves intentionally introducing failures or disturbances into a system to proactively identify weaknesses, vulnerabilities, and failure modes. Chaos engineering helps validate system resilience, improve fault tolerance, and build confidence in distributed systems, including microservices architectures.

28. **Distributed Tracing**: A technique for monitoring and troubleshooting distributed systems by tracking the flow of requests and interactions across multiple services and components. Distributed tracing tools, such as Jaeger or Zipkin, provide visibility into service dependencies, latency, and performance bottlenecks in microservices architectures.

29. **API Gateway**: A central entry point for managing and securing APIs in microservices architectures. API gateways handle authentication, authorization, rate limiting, and request routing, providing a unified interface for client applications to access backend services.

30. **Infrastructure as Code (IaC)**: The practice of defining and provisioning infrastructure resources using code and automation tools. IaC enables reproducible, version-controlled infrastructure deployments and facilitates the management of complex infrastructure configurations in microservices environments.

These additional terminologies and buzzwords further enrich the understanding of key concepts and practices in microservices architecture and related disciplines.


### Core Java design patterns terminologies and buzz words

Certainly! Core Java design patterns are recurring solutions to common problems encountered in software design using the Java programming language. Here are some key terminologies and buzzwords associated with Core Java design patterns:

1. **Design Pattern**: A general reusable solution to a recurring problem in software design. Design patterns provide a common language and set of best practices for expressing and implementing software architecture and solutions.

2. **Creational Patterns**: Design patterns that deal with object creation mechanisms, providing flexible ways to create objects while decoupling the construction logic from the object creation process.
   - **Singleton Pattern**: Ensures that a class has only one instance and provides a global point of access to that instance.
   - **Factory Method Pattern**: Defines an interface for creating objects but allows subclasses to alter the type of objects that will be created.
   - **Abstract Factory Pattern**: Provides an interface for creating families of related or dependent objects without specifying their concrete classes.

3. **Structural Patterns**: Design patterns that focus on organizing classes and objects in a structure that simplifies the system architecture and promotes code reusability.
   - **Adapter Pattern**: Allows incompatible interfaces to work together by wrapping an existing class with a new interface.
   - **Decorator Pattern**: Adds new functionality to an object dynamically by wrapping it with one or more decorator objects.
   - **Composite Pattern**: Represents objects hierarchically as part-whole relationships, allowing clients to treat individual objects and compositions of objects uniformly.

4. **Behavioral Patterns**: Design patterns that govern the interaction and communication between objects, focusing on how objects collaborate to accomplish tasks.
   - **Observer Pattern**: Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.
   - **Strategy Pattern**: Defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.
   - **Command Pattern**: Encapsulates a request as an object, thereby allowing for parameterization of clients with queues, requests, and operations.

5. **Concurrency Patterns**: Design patterns that address the challenges of writing concurrent and multi-threaded programs, ensuring correct and efficient synchronization and communication between threads.
   - **Producer-Consumer Pattern**: Coordinates the work of multiple threads by separating tasks into producers that create data and consumers that process data.
   - **Readers-Writers Pattern**: Controls access to shared resources between multiple readers and writers, allowing concurrent read access but exclusive write access.

6. **Anti-Patterns**: Common pitfalls or bad practices in software design that should be avoided as they can lead to inefficiencies, code complexity, and maintainability issues.
   - **God Object**: A class that knows too much or does too much, violating the single responsibility principle and making the code difficult to understand and maintain.
   - **Spaghetti Code**: Unstructured and tangled code that is difficult to read, debug, and modify, typically resulting from poor design and lack of separation of concerns.

7. **Immutable Objects**: Objects whose state cannot be modified after creation, providing benefits such as thread safety, simplicity, and predictability in concurrent and distributed environments.

8. **Java Collections Framework**: A set of interfaces, implementations, and algorithms provided by Java for managing and manipulating collections of objects, such as lists, sets, maps, and queues.

9. **Lambda Expressions and Functional Interfaces**: Java features introduced in Java 8 that enable functional programming constructs, such as lambda expressions, method references, and functional interfaces, facilitating concise and expressive code for implementing design patterns like Strategy and Observer.

These are some of the key terminologies and concepts related to Core Java design patterns. Understanding these patterns and principles can help Java developers write cleaner, more maintainable, and efficient code.


### Java 8 terminologies and buzz words

Java 8 introduced several significant features and enhancements to the Java programming language and platform. Here are some key terminologies and buzzwords associated with Java 8:

1. **Lambda Expressions**: A new language feature that allows the definition of anonymous functions (also known as closures) in Java. Lambda expressions provide a concise syntax for representing functional interfaces, enabling more expressive and readable code.

2. **Functional Interfaces**: Interfaces that have exactly one abstract method, known as a functional method. Functional interfaces are used in conjunction with lambda expressions and method references to provide functional programming capabilities in Java.

3. **Stream API**: A new API introduced in Java 8 for processing collections of elements in a functional style. Streams enable operations such as map, filter, reduce, and collect to be performed on collections with concise and declarative syntax, promoting functional programming paradigms.

4. **Method References**: A shorthand syntax for referring to methods or constructors using the `::` operator. Method references simplify the usage of lambda expressions for invoking methods and provide a more concise alternative for certain lambda expressions.

5. **Default Methods**: A feature that allows interfaces to provide method implementations, enabling backward compatibility with existing code while still evolving interfaces with new methods. Default methods reduce the need for abstract classes and facilitate API evolution.

6. **Optional**: A container object that may or may not contain a non-null value. Optional is designed to prevent null pointer exceptions by encouraging explicit handling of potentially absent values, improving code robustness and readability.

7. **Date and Time API**: A new API introduced in Java 8 for handling date and time values in a more flexible, comprehensive, and thread-safe manner. The Date and Time API addresses the shortcomings of the legacy `java.util.Date` and `java.util.Calendar` classes and provides improved support for date and time operations.

8. **CompletableFuture**: A class that represents a future result of an asynchronous computation in Java. CompletableFuture provides a flexible and composable way to perform asynchronous tasks, enabling non-blocking and parallel execution of tasks with support for chaining and combining results.

9. **Parallel Streams**: Streams that leverage the parallel processing capabilities of multi-core processors to perform operations concurrently on collections. Parallel streams enable improved performance for CPU-intensive operations by distributing workloads across multiple threads.

10. **Nashorn JavaScript Engine**: A lightweight, high-performance JavaScript engine that is integrated into the Java platform in Java 8. Nashorn provides seamless interoperability between Java and JavaScript, allowing developers to embed and execute JavaScript code within Java applications.

11. **Functional Programming**: A programming paradigm that treats computation as the evaluation of mathematical functions and emphasizes immutable data, higher-order functions, and declarative programming style. Java 8 introduces functional programming constructs, such as lambda expressions and streams, to support functional programming principles in Java.

12. **Type Annotations**: Annotations that can be applied to types, such as classes, interfaces, and type parameters, in addition to the existing element annotations. Type annotations enable stronger type checking, improved documentation, and enhanced tooling support for type-related metadata in Java programs.

These are some of the key terminologies and concepts introduced in Java 8. Understanding these features can help developers leverage the power and capabilities of Java 8 to write more expressive, concise, and maintainable code.

### OOPs (Object-oriented programming) concept terminologies and buzz words

Certainly! Object-oriented programming (OOP) is a programming paradigm that relies on the concept of "objects" to organize and structure code. Here are some key terminologies and buzzwords associated with object-oriented programming and OOP concepts:

1. **Class**: A blueprint for creating objects, defining their properties (attributes) and behaviors (methods). Classes serve as templates for creating multiple instances of objects with similar characteristics.

2. **Object**: An instance of a class that encapsulates data (attributes) and behavior (methods). Objects represent real-world entities or concepts and interact with each other by sending messages and invoking methods.

3. **Encapsulation**: The bundling of data and methods that operate on the data within a single unit, known as a class. Encapsulation hides the internal state of an object and exposes only the necessary interfaces for interacting with it, promoting data integrity and abstraction.

4. **Inheritance**: A mechanism that allows a class (subclass or derived class) to inherit properties and behaviors from another class (superclass or base class). Inheritance enables code reuse, extensibility, and hierarchical organization of classes.

5. **Polymorphism**: The ability of objects to exhibit different behaviors or methods depending on their type or class hierarchy. Polymorphism enables dynamic method dispatch, method overriding, and subtype polymorphism, enhancing code flexibility and extensibility.

6. **Abstraction**: The process of modeling complex systems or concepts by focusing on the essential features and ignoring irrelevant details. Abstraction enables the creation of simplified and generalized models that capture the essence of real-world entities, facilitating code design and understanding.

7. **Interface**: A contract specifying a set of methods that a class must implement. Interfaces define a common behavior or capability that can be shared by multiple classes, promoting code modularity, flexibility, and polymorphism.

8. **Composition**: A design principle that involves combining simple or smaller components (objects) to create more complex objects or systems. Composition enables building complex structures from reusable components and promotes code reuse and modularity.

9. **Association**: A relationship between two classes that indicates how they are related or connected. Associations can be one-to-one, one-to-many, or many-to-many and can represent various types of relationships, such as aggregation, composition, or dependency.

10. **Aggregation**: A type of association that represents a "has-a" relationship between classes, where one class (the whole) contains or is composed of other classes (parts) that have an independent lifecycle. Aggregation implies a weaker relationship than composition and allows parts to exist independently of the whole.

11. **Composition**: A stronger form of aggregation in which the lifecycle of the contained objects (parts) is tightly bound to the lifecycle of the containing object (whole). Composition implies ownership and responsibility for managing the lifecycle of the contained objects.

12. **Overloading**: The ability to define multiple methods in a class with the same name but different parameter lists. Method overloading enables creating methods that perform similar tasks but accept different types or numbers of arguments, enhancing code readability and flexibility.

13. **Overriding**: The process of providing a new implementation for a method in a subclass that is already defined in its superclass. Method overriding allows subclasses to customize or extend the behavior of inherited methods, enabling polymorphism and dynamic method dispatch.

14. **Static**: A keyword in Java used to declare members (variables and methods) that belong to the class itself rather than to individual instances (objects) of the class. Static members are shared among all instances of the class and can be accessed using the class name.

15. **Final**: A keyword in Java used to restrict the modification or extension of classes, methods, or variables. Final classes cannot be subclassed, final methods cannot be overridden, and final variables cannot be reassigned after initialization.

These are some of the key terminologies and concepts associated with object-oriented programming (OOP) and the principles of OOP. Understanding these concepts is essential for writing well-structured, maintainable, and extensible code in Java and other object-oriented programming languages.


### Java concurrency terminologies and buzz words

Certainly! Java concurrency refers to the ability of Java programs to execute multiple tasks concurrently, allowing for parallel execution and efficient utilization of system resources. Here are some key terminologies and buzzwords associated with Java concurrency:

1. **Thread**: A lightweight process that represents a single sequential flow of control within a Java program. Threads enable concurrent execution of tasks and allow programs to perform multiple operations simultaneously.

2. **Multithreading**: The concurrent execution of multiple threads within a single process or program. Multithreading enables programs to perform tasks concurrently, improving performance, responsiveness, and resource utilization.

3. **Concurrency**: The property of a program that allows multiple tasks or operations to make progress simultaneously. Concurrency enables efficient utilization of system resources, better responsiveness, and improved scalability in multi-user or multi-tasking environments.

4. **Thread Safety**: The property of a program or data structure that ensures correct behavior in a multithreaded environment. Thread-safe code or data structures can be accessed and modified by multiple threads concurrently without causing data corruption or race conditions.

5. **Synchronization**: The coordination of access to shared resources or critical sections of code by multiple threads to prevent data races and ensure thread safety. Synchronization mechanisms, such as locks, monitors, and synchronized blocks, serialize access to shared resources and establish mutual exclusion.

6. **Race Condition**: A situation that occurs in a multithreaded program when the outcome of operations depends on the relative timing or interleaving of thread execution. Race conditions can lead to non-deterministic behavior, data corruption, and program failures if not properly handled.

7. **Lock**: A synchronization mechanism used to control access to shared resources by multiple threads. Locks provide exclusive access to critical sections of code or data structures, preventing concurrent modification and ensuring thread safety.

8. **Monitor**: A synchronization construct provided by the Java Virtual Machine (JVM) to coordinate access to synchronized methods and blocks. Monitors use intrinsic locks (also known as mutexes) to enforce mutual exclusion and ensure thread-safe access to shared resources.

9. **Semaphore**: A synchronization primitive that controls access to a shared resource by limiting the number of threads that can simultaneously acquire a lock or access the resource. Semaphores are used to manage access to finite resources and implement concurrency control mechanisms.

10. **Deadlock**: A situation that occurs when two or more threads are blocked indefinitely, waiting for each other to release resources that they need to proceed. Deadlocks can occur due to improper synchronization, incorrect locking order, or resource contention, leading to program hang or deadlock.

11. **Thread Pool**: A managed collection of pre-initialized threads that are available for executing tasks concurrently. Thread pools improve performance and resource utilization by reusing threads for multiple tasks, avoiding the overhead of creating and destroying threads frequently.

12. **Executor Framework**: A framework provided by the `java.util.concurrent` package for managing thread execution and scheduling tasks asynchronously. The Executor framework abstracts the details of thread management and provides higher-level abstractions for executing tasks, such as `ExecutorService` and `ScheduledExecutorService`.

13. **Fork-Join Framework**: A framework provided by the `java.util.concurrent` package for parallelizing recursive divide-and-conquer algorithms. The Fork-Join framework uses a work-stealing algorithm to dynamically distribute tasks among worker threads, maximizing parallelism and efficiency.

14. **Atomic Operations**: Operations that are performed atomically (indivisibly) without interference from other threads. Atomic operations ensure thread safety and prevent data races by guaranteeing that certain operations, such as read-modify-write operations, are performed in a single, uninterruptible step.

15. **Volatile Keyword**: A keyword in Java used to declare variables that are subject to visibility guarantees and atomicity constraints in a multithreaded environment. Volatile variables ensure that changes made by one thread are immediately visible to other threads and prevent certain types of data races.

These are some of the key terminologies and concepts associated with Java concurrency and multithreading. Understanding these concepts is essential for writing scalable, efficient, and thread-safe Java applications that leverage the benefits of concurrent execution.

### JDBC terminologies and buzz words

Certainly! JDBC (Java Database Connectivity) is a Java API for connecting and interacting with relational databases. Here are some key terminologies and buzzwords associated with JDBC:

1. **Driver**: A software component that provides the necessary functionality to connect Java applications to specific database management systems (DBMS). JDBC drivers implement the JDBC API and translate JDBC calls into database-specific commands.

2. **JDBC URL**: A Uniform Resource Locator (URL) used to specify the connection details and parameters for establishing a connection to a database. JDBC URLs typically include information such as the database type, host address, port number, database name, and authentication credentials.

3. **Connection**: A JDBC object representing a connection to a database. Connections are used to establish communication with a database server, execute SQL statements, and manage transactions.

4. **Statement**: A JDBC object used to execute SQL statements against a database. Statements can be of three types: `Statement` for executing simple SQL queries, `PreparedStatement` for executing parameterized SQL queries, and `CallableStatement` for executing stored procedures.

5. **ResultSet**: A JDBC object representing the result of executing a SQL query. ResultSets encapsulate the retrieved rows of a query and provide methods for navigating, accessing, and manipulating the data returned by the query.

6. **Metadata**: Information about the structure and properties of a database, such as the names and data types of tables, columns, and indexes. JDBC provides metadata interfaces, such as `DatabaseMetaData` and `ResultSetMetaData`, for retrieving and querying metadata from a database.

7. **Transaction**: A logical unit of work performed against a database that consists of one or more SQL statements. Transactions ensure data consistency and integrity by providing mechanisms for committing changes (making them permanent) or rolling back changes (undoing them) in case of errors or failures.

8. **Batch Processing**: A technique for executing multiple SQL statements as a single batch to improve performance and reduce database round-trips. JDBC supports batch processing through the `addBatch()` and `executeBatch()` methods of `Statement` and `PreparedStatement` objects.

9. **Connection Pooling**: A mechanism for managing and reusing database connections to minimize the overhead of establishing new connections. Connection pooling frameworks, such as Apache DBCP and HikariCP, maintain a pool of pre-initialized database connections that can be borrowed and returned by applications as needed.

10. **DataSource**: A JDBC interface representing a factory for creating database connections. DataSources provide a standardized way to obtain database connections in Java applications and support connection pooling, transaction management, and resource optimization.

11. **DriverManager**: A JDBC class responsible for managing JDBC drivers and establishing database connections. The DriverManager class provides methods for registering drivers, obtaining connections, and configuring connection properties.

12. **SQL Injection**: A security vulnerability that occurs when untrusted user input is improperly handled in SQL queries, allowing attackers to execute arbitrary SQL commands or manipulate the behavior of database queries. JDBC provides mechanisms, such as prepared statements and parameterized queries, to prevent SQL injection attacks.

13. **Connection Pool**: A collection of reusable database connections maintained by a connection pooling framework. Connection pools manage the lifecycle of database connections, including creation, validation, and recycling, to improve performance and scalability in multi-user or multi-threaded environments.

14. **Statement Pooling**: A technique for reusing prepared statements or callable statements to avoid the overhead of parsing and compiling SQL queries repeatedly. Statement pooling frameworks, such as Apache Commons DBCP, cache and manage prepared statements to improve database performance and resource utilization.

15. **Transaction Isolation**: The degree to which the changes made by one transaction are visible to other concurrent transactions. JDBC supports different levels of transaction isolation, such as `READ_UNCOMMITTED`, `READ_COMMITTED`, `REPEATABLE_READ`, and `SERIALIZABLE`, to control the visibility and consistency of data in concurrent transactions.

These are some of the key terminologies and concepts associated with JDBC, which are essential for understanding and working with database connectivity in Java applications.


### JSP terminologies and buzz words

Certainly! JSP (JavaServer Pages) is a technology used for creating dynamic web pages with Java. Here are some key terminologies and buzzwords associated with JSP:

1. **Dynamic Web Pages**: Web pages that are generated dynamically by a web server in response to client requests. JSP allows developers to embed Java code directly into HTML pages, enabling the creation of dynamic content and interactions with web users.

2. **Servlet**: A Java program that runs on the server side to handle client requests and generate dynamic web content. JSP pages are ultimately translated into servlets by the JSP container, allowing for the execution of Java code and the generation of HTML output.

3. **JSP Container**: A component of a web server or application server responsible for processing JSP pages, compiling them into servlets, and executing them to generate dynamic web content. Examples of JSP containers include Apache Tomcat, Jetty, and GlassFish.

4. **Scriptlet**: A block of Java code embedded within a JSP page using `<% %>` tags. Scriptlets allow developers to execute Java logic, perform calculations, and access data from within the JSP page, enabling dynamic content generation based on user input or application state.

5. **Expression Language (EL)**: A language used to simplify the access and manipulation of data within JSP pages. EL expressions are enclosed within `${ }` tags and can be used to retrieve values from JavaBeans, session attributes, request parameters, and other objects stored in the page context.

6. **Standard Actions**: Predefined XML-like tags provided by JSP for performing common tasks, such as including other files, forwarding requests, setting variables, iterating over collections, and manipulating HTTP headers. Standard actions provide a declarative way to perform common operations without writing Java code directly.

7. **Custom Tags**: User-defined tags created by developers to encapsulate reusable components or functionality within JSP pages. Custom tags allow for modularization, abstraction, and reuse of code, promoting code maintainability and readability.

8. **Tag Libraries**: Collections of custom tags organized into reusable components or libraries for use in JSP pages. Tag libraries provide a higher level of abstraction and encapsulation compared to scriptlets and standard actions, enabling the development of more modular and maintainable web applications.

9. **JSP Directive**: Special instructions or directives provided by JSP for controlling the behavior of the JSP container during page translation and execution. Directives include `page`, `include`, and `taglib` directives, which specify page attributes, include other files, and import tag libraries, respectively.

10. **JSP Lifecycle**: The sequence of events and phases that occur during the processing of a JSP page by the JSP container. The JSP lifecycle includes stages such as translation, compilation, initialization, execution, and destruction, which determine how JSP pages are processed and executed.

11. **Model-View-Controller (MVC)**: A design pattern used to organize web applications into three separate components: the model (business logic and data), the view (presentation layer), and the controller (request handling and flow control). JSP is often used as the view component in MVC architectures, separating presentation logic from application logic.

12. **JavaBean**: A reusable component or Java class that encapsulates data and provides accessor and mutator methods for accessing and manipulating the data. JavaBeans are commonly used in JSP pages to represent business entities, manage application state, and interact with databases or other backend systems.

13. **Request Scope**: The scope or lifespan of objects and data associated with a single HTTP request in a web application. Request-scoped objects, such as request parameters and attributes, are accessible only within the context of the current request and are discarded after the request is processed.

14. **Session Scope**: The scope or lifespan of objects and data associated with a single user session in a web application. Session-scoped objects, such as session attributes, are persistent across multiple requests from the same user and are typically stored on the server side, enabling stateful interactions and user-specific customization.

15. **Page Directive**: A JSP directive used to specify various attributes and settings for the current JSP page, such as the page language, content type, error handling, and buffer size. Page directives are defined using `<%@ page %>` tags and provide metadata and configuration options for controlling the behavior of the JSP container.

These are some of the key terminologies and concepts associated with JSP, which are essential for understanding and developing dynamic web applications using JavaServer Pages.


### JSTL (JavaServer Pages Standard Tag Library) terminologies and buzz words

JSTL (JavaServer Pages Standard Tag Library) is a collection of custom tags and functions designed to simplify the development of JSP (JavaServer Pages) pages. Here are some key terminologies and buzzwords associated with JSTL:

1. **Tag Library**: A collection of custom tags and functions that extend the capabilities of JSP pages. JSTL provides a standard set of tags and functions for performing common tasks, such as iteration, conditionals, formatting, and internationalization, without writing Java code directly.

2. **Core Tags**: A set of JSTL tags used for basic control flow, iteration, variable manipulation, and URL management within JSP pages. Core tags include `<c:if>`, `<c:forEach>`, `<c:set>`, `<c:remove>`, `<c:url>`, and `<c:choose>`, among others.

3. **Formatting Tags**: JSTL tags used for formatting and internationalization of data within JSP pages. Formatting tags include `<fmt:formatDate>`, `<fmt:formatNumber>`, `<fmt:parseNumber>`, and `<fmt:message>`, which provide support for date, number, and message formatting based on locale settings.

4. **SQL Tags**: Deprecated JSTL tags used for executing SQL queries and accessing relational databases within JSP pages. SQL tags include `<sql:setDataSource>`, `<sql:query>`, `<sql:update>`, and `<sql:param>`, which are typically replaced by more robust and secure approaches, such as JDBC or ORM frameworks.

5. **XML Tags**: JSTL tags used for processing XML data within JSP pages. XML tags include `<x:parse>`, `<x:out>`, `<x:forEach>`, and `<x:choose>`, which provide support for parsing, rendering, and manipulating XML documents and nodes.

6. **EL Functions**: A set of utility functions provided by JSTL for performing common operations within EL (Expression Language) expressions. EL functions include functions for string manipulation, date and time operations, mathematical calculations, and collection manipulation, such as `fn:length()`, `fn:substring()`, `fn:concat()`, and `fn:contains()`.

7. **Taglib Directive**: A JSP directive used to declare the usage of a tag library within a JSP page. The taglib directive specifies the prefix and URI (Uniform Resource Identifier) of the tag library, allowing JSP pages to reference and use the custom tags and functions provided by the library.

8. **JSP Expression Language (EL)**: A language used to simplify the access and manipulation of data within JSP pages. EL expressions are enclosed within `${ }` tags and can be used to retrieve values from JavaBeans, session attributes, request parameters, and other objects stored in the page context.

9. **Standard Actions**: Predefined XML-like tags provided by JSTL for performing common tasks within JSP pages. Standard actions include conditional statements (`<c:if>`), iteration (`<c:forEach>`), setting variables (`<c:set>`), removing variables (`<c:remove>`), and handling errors (`<c:catch>`).

10. **Custom Tags**: User-defined tags created by developers to encapsulate reusable components or functionality within JSP pages. Custom tags allow for modularization, abstraction, and reuse of code, promoting code maintainability and readability.

11. **JSTL Functions**: A collection of utility functions provided by JSTL for performing common operations within JSP pages. JSTL functions include functions for string manipulation, date and time operations, mathematical calculations, and collection manipulation, such as `fn:length()`, `fn:substring()`, `fn:concat()`, and `fn:contains()`.

These are some of the key terminologies and concepts associated with JSTL, which are essential for understanding and leveraging the capabilities of JavaServer Pages Standard Tag Library in web development with JSP.

### Servlets terminologies and buzz words

Certainly! Servlets are Java programs that run on the server side to handle client requests and generate dynamic web content. Here are some key terminologies and buzzwords associated with servlets:

1. **Servlet Container**: A runtime environment provided by a web server or application server for executing servlets. Servlet containers manage the lifecycle of servlets, handle client requests, and generate dynamic responses, adhering to the Java Servlet API specifications.

2. **Java Servlet API**: A standard Java API provided by the Java EE (Enterprise Edition) platform for developing server-side web applications using servlets. The Servlet API defines the contract between servlets and servlet containers, specifying servlet lifecycle, request handling, response generation, and other functionalities.

3. **HTTP Servlet**: A subclass of the `javax.servlet.http.HttpServlet` class used for handling HTTP requests and generating HTTP responses in servlet-based web applications. HTTP servlets implement the `doGet()`, `doPost()`, `doPut()`, `doDelete()`, and other methods to handle different HTTP methods and request types.

4. **Servlet Lifecycle**: The sequence of states and events that occur during the lifecycle of a servlet within a servlet container. The servlet lifecycle includes stages such as initialization, service, destruction, and garbage collection, which determine how servlet instances are created, executed, and cleaned up by the container.

5. **Initialization**: The process of initializing a servlet and preparing it for handling client requests. Servlet initialization occurs when the servlet container loads the servlet class, creates an instance, and calls the `init()` method to perform initialization tasks, such as reading configuration parameters and establishing resources.

6. **Request Handling**: The process of processing client requests and generating responses within a servlet. Servlets handle incoming HTTP requests by implementing the `service()` method or specific HTTP method handlers (`doGet()`, `doPost()`, etc.), parsing request parameters, invoking business logic, and generating dynamic content or forwarding requests to other components.

7. **Response Generation**: The process of generating and sending HTTP responses back to clients from within a servlet. Servlets construct HTTP responses by setting response headers, writing content to the response body, and sending the response back to the client using the `HttpServletResponse` object provided by the servlet container.

8. **Session Management**: The process of managing user sessions and maintaining session state across multiple requests within a servlet-based web application. Servlets use session management techniques, such as cookies, URL rewriting, and session objects (`HttpSession`), to associate user data with unique session identifiers and track user interactions over time.

9. **Servlet Mapping**: The association of URL patterns or request URIs with servlets within a web application deployment descriptor (web.xml) or using annotations. Servlet mapping determines which servlet should handle incoming requests based on the requested URL, enabling dispatching of requests to appropriate servlets.

10. **Filter**: A Java component used for intercepting and processing HTTP requests and responses before they reach the servlet or after they have been processed by the servlet. Filters provide reusable and pluggable components for implementing cross-cutting concerns, such as authentication, authorization, logging, and request/response modification.

11. **Listener**: A Java component used for listening to and handling lifecycle events within a servlet container. Servlet listeners, such as `ServletContextListener`, `ServletRequestListener`, and `HttpSessionListener`, enable applications to respond to container events, such as context initialization, request arrival, session creation, and attribute changes.

12. **Context Initialization**: The process of initializing the servlet context and application-wide resources within a servlet container. Servlet context initialization occurs when the container starts up and deploys the web application, allowing servlets to perform global initialization tasks, such as database connection pooling, resource loading, and configuration setup.

13. **Forwarding**: The process of internally redirecting an HTTP request from one servlet to another servlet, JSP page, or resource within the same web application. Servlet forwarding allows servlets to delegate request processing to other components while maintaining the original request URL and attributes.

14. **Include**: The process of including the output of another servlet, JSP page, or resource within the response generated by the current servlet. Servlet inclusion allows servlets to reuse and compose dynamic content from multiple sources, such as header and footer components, within the same response.

15. **Asynchronous Processing**: The capability of servlets to handle long-running tasks or non-blocking I/O operations asynchronously, without tying up server resources or blocking other requests. Servlet asynchronous processing allows for improved scalability, responsiveness, and resource utilization in servlet-based web applications.

These are some of the key terminologies and concepts associated with servlets, which are essential for understanding and developing server-side web applications using Java Servlet technology.


### Webpack terminologies and buzz words

Certainly! Webpack is a popular module bundler for JavaScript applications. Here are some key terminologies and buzzwords associated with Webpack:

1. **Module Bundler**: A tool used to bundle multiple modules or files into a single bundle for deployment in web applications. Webpack analyzes dependencies between modules, resolves import statements, and generates optimized bundles that include all required assets, such as JavaScript, CSS, images, and fonts.

2. **Entry Point**: The starting point or main file of a Webpack application where the bundling process begins. The entry point specifies the module or file that Webpack should use as the root of the dependency graph when building the application bundle.

3. **Output**: The generated bundle or output file produced by Webpack after bundling all modules and dependencies. The output configuration in Webpack specifies the filename and location of the output bundle, as well as additional settings such as public path and bundle format.

4. **Loader**: A Webpack plugin used to preprocess or transform files before they are included in the bundle. Loaders enable Webpack to handle different types of files, such as JavaScript, CSS, HTML, and images, by applying transformations, such as transpilation, minification, and optimization, using loaders such as Babel, CSS-loader, and file-loader.

5. **Plugin**: A Webpack extension or add-on used to perform custom tasks or optimizations during the bundling process. Plugins provide hooks and APIs for modifying the Webpack build process, injecting additional functionality, and optimizing output bundles. Common Webpack plugins include HtmlWebpackPlugin, UglifyJsPlugin, and MiniCssExtractPlugin.

6. **Code Splitting**: A technique used to split the application code into multiple bundles or chunks to improve performance and reduce initial loading time. Webpack supports code splitting using dynamic import statements, entry points, and splitChunks optimization to generate smaller bundles that can be loaded asynchronously as needed.

7. **Tree Shaking**: A process of eliminating dead code or unused modules from the final bundle to reduce its size and improve runtime performance. Webpack uses tree shaking in conjunction with module bundling and static analysis to identify and remove unused exports and dependencies from the application code.

8. **Hot Module Replacement (HMR)**: A feature of Webpack that enables real-time updating of modules in the browser without requiring a full page reload. HMR allows developers to make code changes and see the results instantly in the browser, improving development workflow and productivity.

9. **DevServer**: A built-in development server provided by Webpack for serving the bundled application and supporting features such as hot module replacement, live reloading, and HTTP proxying during development. DevServer enables rapid iteration and testing of changes without the need for manual setup or configuration.

10. **Mode**: A configuration option in Webpack that specifies the build mode or environment, such as development or production. The mode setting influences various aspects of the bundling process, including optimization, output size, and error reporting, to optimize performance and generate optimized bundles for different environments.

11. **Webpack Configuration**: A JavaScript configuration file (typically named webpack.config.js) used to customize and configure the behavior of Webpack for a specific project. The Webpack configuration file defines entry points, output settings, loaders, plugins, optimization options, and other parameters required for building the application bundle.

12. **Chunk**: A unit of code or bundle generated by Webpack during the bundling process, representing a group of modules and dependencies. Webpack generates chunks based on entry points, code splitting, and optimization settings to optimize resource loading and improve application performance.

13. **Asset Management**: The process of handling static assets, such as images, fonts, and media files, in a Webpack application. Webpack provides loaders and plugins for importing and processing assets, optimizing file size, and generating asset URLs in the output bundle.

14. **Module Resolution**: The process of resolving import statements and module dependencies within a Webpack application. Webpack uses module resolution rules, such as file extensions, aliases, and module paths, to locate and load modules from the file system or node_modules directory.

15. **Webpack CLI**: Command-line interface (CLI) tool for running Webpack commands, managing project configurations, and executing build tasks from the terminal. Webpack CLI provides commands for building, watching, analyzing, and serving Webpack bundles, as well as options for configuring the build process.

These are some of the key terminologies and concepts associated with Webpack, which are essential for understanding and configuring the module bundling process in modern JavaScript applications.

### Rollup.js terminologies and buzz words

Certainly! Rollup.js is another popular module bundler for JavaScript applications, with a focus on generating optimized bundles for production use. Here are some key terminologies and buzzwords associated with Rollup.js:

1. **Module Bundler**: Similar to Webpack, Rollup.js is a tool used to bundle multiple modules or files into a single bundle for deployment in web applications. Rollup analyzes module dependencies and generates optimized bundles that leverage ES6 module features and tree-shaking for better performance.

2. **ES Module**: ECMAScript (ES) modules are a standard module system introduced in ES6 (ES2015) for organizing and structuring JavaScript code. Rollup supports ES modules natively and encourages the use of ES6 module syntax for better interoperability, readability, and tree-shaking optimization.

3. **Tree-Shaking**: A process of eliminating dead code or unused modules from the final bundle to reduce its size and improve runtime performance. Rollup.js uses tree shaking to analyze module dependencies statically and remove unused exports and dependencies from the application code, resulting in smaller and more efficient bundles.

4. **Entry Point**: The main file or module of a Rollup.js application where the bundling process begins. The entry point specifies the starting point of the dependency graph, and Rollup recursively resolves and bundles all dependencies into a single output bundle.

5. **Output Options**: Configuration settings in Rollup.js that specify the filename, format, and other properties of the output bundle generated by the bundling process. Rollup output options allow developers to customize the output bundle format, such as ES module, CommonJS, AMD, UMD, or IIFE (Immediately Invoked Function Expression).

6. **Plugin**: A Rollup.js extension or add-on used to customize and extend the functionality of the bundling process. Rollup plugins provide hooks and APIs for transforming files, handling assets, optimizing output, and integrating with third-party tools and libraries, such as Babel, TypeScript, and CSS preprocessors.

7. **Rollup Configuration**: A JavaScript configuration file (typically named rollup.config.js) used to define and customize the behavior of Rollup.js for a specific project. The Rollup configuration file specifies entry points, output options, plugins, and other parameters required for building the application bundle.

8. **Chunk**: A unit of code or bundle generated by Rollup.js during the bundling process, representing a group of modules and dependencies. Rollup generates chunks based on entry points, module imports, and code splitting techniques to optimize resource loading and improve application performance.

9. **Code Splitting**: A technique used to split the application code into multiple chunks or bundles to improve performance and reduce initial loading time. Rollup.js supports code splitting by generating separate bundles for different entry points or dynamically imported modules, allowing for better resource management and lazy loading.

10. **Dynamic Import**: A feature of JavaScript that allows modules to be imported asynchronously at runtime using dynamic import statements (`import()`). Rollup.js supports dynamic import syntax for code splitting and generating separate bundles for dynamically loaded modules, enabling lazy loading and better performance optimization.

11. **Optimization**: The process of optimizing the output bundle generated by Rollup.js for better performance and efficiency. Rollup provides built-in optimizations, such as tree shaking, minification, code splitting, and scope hoisting, to reduce bundle size, improve runtime performance, and minimize load times.

12. **Scope Hoisting**: An optimization technique used by Rollup.js to reduce bundle size and improve runtime performance by hoisting module scopes and sharing module bindings across multiple modules. Scope hoisting eliminates redundant code and reduces function call overhead, resulting in smaller and faster bundles.

13. **Watch Mode**: A development mode in Rollup.js that monitors file changes and automatically rebuilds the output bundle whenever a source file is modified. Rollup watch mode enables rapid iteration and testing of changes during development, providing instant feedback without manual rebuilding.

14. **External Dependencies**: Dependencies that are not bundled into the output bundle by Rollup.js and are expected to be provided by the runtime environment or loaded separately at runtime. Rollup supports specifying external dependencies to exclude them from the bundle and generate import statements for dynamic loading.

15. **Advanced Configuration**: Advanced configuration options and features provided by Rollup.js for fine-tuning and optimizing the bundling process. Rollup allows developers to customize module resolution, output formats, asset handling, source maps, and other aspects of the bundling process to meet specific project requirements.

These are some of the key terminologies and concepts associated with Rollup.js, which are essential for understanding and configuring the module bundling process in JavaScript applications using Rollup.js.


### Javascript terminologies and buzz words

Certainly! JavaScript is a versatile programming language widely used for building web applications, server-side applications, mobile apps, and more. Here are some key terminologies and buzzwords associated with JavaScript:

1. **JavaScript (JS)**: A high-level, interpreted programming language primarily used for client-side web development. JavaScript enables dynamic behavior, interactivity, and manipulation of web page content within web browsers.

2. **ECMAScript (ES)**: The official standard specification for JavaScript maintained by Ecma International. ECMAScript defines the syntax, semantics, and behavior of JavaScript, ensuring consistency and interoperability across different implementations and environments.

3. **Frontend**: The client-facing part of a web application or website that users interact with directly in their web browsers. Frontend development involves designing and implementing user interfaces, interactivity, and functionality using HTML, CSS, and JavaScript.

4. **Backend**: The server-side part of a web application or website responsible for processing requests, executing business logic, and interacting with databases or external services. Backend development involves implementing server-side logic, APIs, and data storage using programming languages such as JavaScript (Node.js), Python, Ruby, PHP, etc.

5. **Node.js**: A runtime environment for executing JavaScript code outside the web browser, typically on the server side. Node.js enables developers to build scalable, high-performance server applications using JavaScript, leveraging event-driven, non-blocking I/O model.

6. **Package Manager**: A tool used to manage dependencies, libraries, and third-party packages in JavaScript projects. Package managers, such as npm (Node Package Manager) and Yarn, provide commands for installing, updating, and removing packages from project dependencies.

7. **Framework**: A software framework or library that provides pre-written code, utilities, and abstractions to facilitate application development and streamline common tasks. JavaScript frameworks, such as Angular, React, and Vue.js, are widely used for building frontend user interfaces and single-page applications (SPAs).

8. **Library**: A collection of reusable code modules, functions, and utilities that provide specific functionality or solve common programming tasks. JavaScript libraries, such as jQuery, Lodash, and Axios, are often used to simplify DOM manipulation, data manipulation, and AJAX requests in web applications.

9. **Asynchronous Programming**: A programming paradigm used to handle operations that may take significant time to complete, such as I/O operations or network requests, without blocking the execution of the main program. JavaScript supports asynchronous programming using callbacks, promises, and async/await syntax.

10. **Callback Function**: A function passed as an argument to another function and invoked asynchronously to handle the result of an asynchronous operation or event. Callback functions are commonly used in JavaScript to execute code after completion of asynchronous tasks, such as AJAX requests or setTimeout.

11. **Promise**: An object representing the eventual completion or failure of an asynchronous operation, typically used to handle asynchronous tasks and manage their results. Promises provide a cleaner and more readable way to write asynchronous code compared to callback-based approaches.

12. **Async/Await**: A modern JavaScript syntax introduced in ES2017 (ES8) for asynchronous programming, providing a more intuitive and synchronous-like way to write asynchronous code using async functions and await expressions. Async/await simplifies error handling and control flow in asynchronous code.

13. **Single-Page Application (SPA)**: A web application or website that dynamically updates and renders content in response to user interactions without reloading the entire page from the server. SPAs use JavaScript frameworks or libraries to manage client-side routing, state management, and view rendering.

14. **DOM Manipulation**: The process of accessing, modifying, or updating the Document Object Model (DOM) of a web page using JavaScript. DOM manipulation allows developers to dynamically change page content, structure, and styles based on user interactions or application logic.

15. **Event Handling**: The process of capturing and responding to user interactions, browser events, or custom events within a web application using JavaScript. Event handling allows developers to define event listeners and callback functions to execute specific actions in response to events, such as clicks, keypresses, or form submissions.

These are some of the key terminologies and concepts associated with JavaScript, which are essential for understanding and developing modern web applications and server-side applications using JavaScript technologies and frameworks.


### Reactjs terminologies and buzz words

Certainly! React.js is a popular JavaScript library for building user interfaces, particularly for single-page applications (SPAs). Here are some key terminologies and buzzwords associated with React.js:

1. **React**: A JavaScript library developed by Facebook for building user interfaces using a component-based architecture. React allows developers to create reusable UI components and manage component state, rendering, and lifecycle efficiently.

2. **Component**: A self-contained and reusable building block of a React application that encapsulates UI elements, behavior, and state. React components can be composed hierarchically to create complex user interfaces, promoting modularity, reusability, and maintainability.

3. **JSX (JavaScript XML)**: A syntax extension for JavaScript used in React to define and render UI components using HTML-like syntax within JavaScript code. JSX allows developers to write expressive and declarative UI code, combining HTML markup with JavaScript expressions and logic.

4. **Virtual DOM (Document Object Model)**: A lightweight, in-memory representation of the actual DOM tree maintained by React for efficient rendering and updates. React uses the virtual DOM to perform diffing and reconciliation between the current and previous states of the DOM, minimizing DOM manipulation and improving performance.

5. **State**: The internal data or state managed by a React component that determines its behavior, appearance, and rendering. React components can have local state managed using the `useState` hook or global state managed using state management libraries like Redux or Context API.

6. **Props (Properties)**: Short for properties, props are inputs passed to React components to customize their behavior, appearance, and content. Props are immutable and are typically used to pass data from parent components to child components, enabling component composition and reusability.

7. **Component Lifecycle**: The sequence of stages or phases that a React component goes through during its lifetime, from initialization to destruction. React components have lifecycle methods, such as `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`, which allow developers to hook into different stages of the component lifecycle and perform actions or side effects.

8. **Hooks**: A feature introduced in React 16.8 for adding stateful and side-effectful behavior to functional components. React hooks, such as `useState`, `useEffect`, `useContext`, and `useReducer`, allow functional components to manage state, handle side effects, access context, and implement custom logic without using class components.

9. **Context API**: A feature in React for passing data through the component tree without explicitly passing props down manually at every level. Context API provides a way to share global state or configuration across multiple components in a React application, simplifying state management and reducing prop drilling.

10. **Conditional Rendering**: The process of conditionally rendering UI components or elements based on certain conditions or expressions. React supports conditional rendering using JavaScript expressions, ternary operators, logical && operator, and conditional rendering patterns such as if statements and switch statements.

11. **List Rendering**: The process of rendering dynamic lists or collections of data as UI components in a React application. React provides map() method and JSX syntax for iterating over arrays or collections and rendering list items dynamically based on the data.

12. **Event Handling**: The process of capturing and handling user interactions, browser events, or custom events within React components. React components use event handlers, such as onClick, onChange, onSubmit, etc., to respond to user actions and trigger specific behavior or updates in the application.

13. **Component Composition**: The practice of composing or combining multiple React components together to create complex user interfaces. React components can be composed hierarchically, allowing for the creation of reusable, modular, and maintainable UI components and layouts.

14. **React Router**: A popular routing library for React applications used for managing navigation and routing between different views or pages in a single-page application. React Router provides declarative routing and navigation components, such as `<BrowserRouter>`, `<Route>`, `<Link>`, and `<Switch>`, for building navigation interfaces.

15. **State Management**: The process of managing application state, data, and state transitions in a React application. React provides built-in state management features using component state and context API, while external libraries like Redux, MobX, and Recoil offer more advanced state management solutions for complex applications.

These are some of the key terminologies and concepts associated with React.js, which are essential for understanding and developing modern web applications using React.js library.

### Reduxjs terminologies and buzz words

Certainly! Redux is a predictable state container for JavaScript applications, commonly used with React for managing application state. Here are some key terminologies and buzzwords associated with Redux:

1. **State**: The single source of truth that represents the entire application state stored in a plain JavaScript object. In Redux, the state is immutable and can only be modified by dispatching actions.

2. **Store**: An object that holds the application state and provides methods for accessing, updating, and subscribing to state changes. The Redux store is created using the `createStore()` function and serves as the central hub for managing state in a Redux application.

3. **Action**: Plain JavaScript objects that represent an intention to change the state of the application. Actions are dispatched to the Redux store using the `dispatch()` method and typically contain a `type` property indicating the type of action and optional payload data.

4. **Reducer**: A pure function that specifies how the application state should change in response to dispatched actions. Reducers take the current state and an action as input and return a new state object without mutating the original state. Redux combines multiple reducers using the `combineReducers()` function to manage different slices of state.

5. **Action Creator**: A function that creates and returns action objects to dispatch to the Redux store. Action creators encapsulate the logic for creating actions and abstract away the details of action construction, making it easier to dispatch actions from components.

6. **Dispatch**: A method provided by the Redux store for dispatching actions to trigger state changes. Components and middleware can dispatch actions using the `dispatch()` function, which passes the action to the root reducer to update the application state.

7. **Middleware**: Functions that intercept and process actions before they reach the reducers, enabling additional functionality such as logging, asynchronous operations, and side effects. Redux middleware sits between the action dispatch and reducer invocation and can modify, delay, or dispatch additional actions based on intercepted actions.

8. **Store Subscription**: A mechanism provided by Redux for subscribing to state changes and receiving notifications whenever the state of the Redux store updates. Components can subscribe to the Redux store using the `subscribe()` method and react to state changes by re-rendering or updating their UI.

9. **Selectors**: Functions used to extract specific pieces of data or computed values from the Redux store state. Selectors provide a way to encapsulate and memoize state access logic, improving performance and maintainability by avoiding unnecessary recomputations.

10. **Immutable Update Patterns**: Patterns and techniques used to update immutable state in Redux reducers without mutating the original state object. Common immutable update patterns include object spread syntax, `Object.assign()`, and libraries like Immer or Immutable.js.

11. **Redux DevTools**: A browser extension or development tool for inspecting and debugging Redux applications. Redux DevTools provides a graphical interface for visualizing state changes, time-travel debugging, and analyzing dispatched actions and state snapshots during development.

12. **Thunks**: A type of Redux middleware used to handle asynchronous logic and side effects in Redux applications. Thunks are functions that can be dispatched as actions and can contain asynchronous code, such as API calls, and dispatch additional actions based on the results.

13. **Selectors**: Functions used to extract specific pieces of data or computed values from the Redux store state. Selectors provide a way to encapsulate and memoize state access logic, improving performance and maintainability by avoiding unnecessary recomputations.

14. **Reselect**: A popular library for creating memoized selectors in Redux applications. Reselect provides memoized selector functions that efficiently compute derived data from the Redux store state and cache the results to prevent unnecessary recomputations.

15. **Async Actions**: Actions that involve asynchronous operations, such as fetching data from an API, waiting for user input, or performing time-delayed tasks. Redux middleware, such as Thunks or Sagas, can handle async actions by dispatching multiple actions asynchronously and handling the results when they resolve.

These are some of the key terminologies and concepts associated with Redux, which are essential for understanding and implementing state management in JavaScript applications using Redux library.

### JWT terminologies and buzz words

JWT (JSON Web Token) is a compact, URL-safe means of representing claims to be transferred between two parties. Here are some key terminologies and buzzwords associated with JWT:

1. **Token**: A string representing a set of claims as a JSON object that is encoded in a compact form. JWT tokens consist of three parts: a header, a payload, and a signature, separated by dots (`.`).

2. **Header**: The first part of a JWT token that contains metadata about the type of token and the cryptographic algorithms used for signing the token. The header typically includes properties such as `alg` (algorithm) and `typ` (token type), encoded as a JSON object.

3. **Payload**: The second part of a JWT token that contains the claims or assertions about the user and additional metadata. The payload includes standard claims (e.g., `iss`, `sub`, `exp`, `iat`) and custom claims defined by the application, encoded as a JSON object.

4. **Signature**: The third part of a JWT token that is used to verify the integrity and authenticity of the token. The signature is generated by encoding the header and payload, appending a secret key known only to the server, and applying a cryptographic algorithm (e.g., HMAC, RSA) to produce a unique hash.

5. **Claims**: Statements or assertions about a subject (e.g., user, client) encoded within the payload of a JWT token. Claims represent information such as user ID, role, permissions, expiration time, and other attributes relevant to authentication and authorization.

6. **Issuer (iss)**: A claim in the JWT payload that identifies the issuer of the token, typically representing the identity provider or authentication service responsible for issuing the token.

7. **Subject (sub)**: A claim in the JWT payload that identifies the subject of the token, typically representing the user or entity associated with the token.

8. **Expiration Time (exp)**: A claim in the JWT payload that specifies the expiration time of the token, expressed as a Unix timestamp or a date/time in ISO 8601 format. After the expiration time, the token is considered invalid and should not be accepted for authentication.

9. **Issued At (iat)**: A claim in the JWT payload that specifies the time at which the token was issued, expressed as a Unix timestamp or a date/time in ISO 8601 format.

10. **Audience (aud)**: A claim in the JWT payload that specifies the intended audience or recipients of the token. The audience claim is optional and can be used to restrict the token's validity to specific clients or services.

11. **Signing Algorithm**: The cryptographic algorithm used to generate the signature for a JWT token, ensuring its integrity and authenticity. Common signing algorithms include HMAC (HS256, HS384, HS512) for symmetric key cryptography and RSA (RS256, RS384, RS512) for asymmetric key cryptography.

12. **Verification**: The process of verifying the integrity and authenticity of a JWT token by validating its signature using the appropriate cryptographic algorithm and verifying the claims within the payload.

13. **Bearer Token**: A type of access token used for authentication and authorization in HTTP requests, typically transmitted in the `Authorization` header using the Bearer authentication scheme (`Bearer <token>`).

14. **Stateless Authentication**: A authentication mechanism in which the server does not maintain session state or store user sessions. JWT tokens enable stateless authentication by containing all necessary information within the token itself, eliminating the need for server-side session storage.

15. **Token Revocation**: The process of invalidating or revoking a JWT token before its expiration time, typically in response to security incidents, user logout, or token expiration. Token revocation mechanisms include blacklisting tokens, using short-lived tokens, and implementing token expiration policies.

These are some of the key terminologies and concepts associated with JWT, which are essential for understanding and implementing token-based authentication and authorization mechanisms in web applications and APIs.


### Java Annotations terminologies and buzz words

Certainly! Java annotations are metadata that provide data about a program but are not part of the program itself. Here are some key terminologies and buzzwords associated with Java annotations:

1. **Annotation**: A form of metadata that provides data about a program, which can be embedded within Java source code, classes, methods, fields, or other program elements. Annotations are defined using the `@` symbol followed by the annotation name, optionally with parameters enclosed in parentheses.

2. **Annotation Type**: A Java interface that defines the structure and semantics of an annotation. Annotation types are declared using the `@interface` keyword, and can include elements representing annotation parameters, default values, and retention policy.

3. **Meta-Annotation**: Annotations that annotate other annotations, providing additional information or directives about the behavior and usage of annotated elements. Meta-annotations include built-in annotations like `@Retention`, `@Target`, `@Documented`, and `@Inherited`.

4. **Retention Policy**: The policy that determines how long an annotation is retained or available at runtime. Java supports three retention policies: `SOURCE`, `CLASS`, and `RUNTIME`, specified using the `@Retention` meta-annotation.

5. **Target**: The type of program elements to which an annotation can be applied. Java annotations can target classes, methods, fields, parameters, packages, and other program elements, specified using the `@Target` meta-annotation.

6. **Documented**: A meta-annotation used to indicate that annotations with this meta-annotation should be documented by JavaDoc tools and included in generated API documentation.

7. **Inherited**: A meta-annotation used to indicate that annotations with this meta-annotation should be inherited by subclasses of annotated classes.

8. **Built-in Annotations**: Predefined annotations provided by the Java language or standard libraries for common tasks such as marking deprecated code (`@Deprecated`), suppressing warnings (`@SuppressWarnings`), and overriding superclass methods (`@Override`).

9. **Custom Annotations**: User-defined annotations created by developers to add metadata and behaviors to their own Java classes and programs. Custom annotations are declared using annotation types and can be used to convey specific information or trigger specific actions at runtime.

10. **Annotation Processor**: A tool or framework used to process and analyze annotations at compile time or runtime, typically to generate code, perform validation, or provide additional functionality based on annotated elements.

11. **Annotation Processing API**: The Java API for processing annotations programmatically within annotation processors. The javax.annotation.processing package provides classes and interfaces for reading, writing, and processing annotations in Java programs.

12. **Reflection**: The mechanism by which a Java program can introspect and manipulate its own structure, metadata, and behavior at runtime. Reflection APIs, such as java.lang.reflect package, enable runtime access to annotations, classes, methods, fields, and other program elements.

13. **Spring Annotations**: Annotations provided by the Spring Framework for configuring and managing Spring-based applications. Spring annotations include `@Component`, `@Autowired`, `@RequestMapping`, `@Service`, `@Controller`, and many others used for dependency injection, MVC configuration, AOP, and more.

14. **JPA Annotations**: Annotations provided by the Java Persistence API (JPA) for mapping Java objects to relational database tables and entities. JPA annotations include `@Entity`, `@Table`, `@Id`, `@GeneratedValue`, `@Column`, and others used for object-relational mapping (ORM) and database access.

15. **JUnit Annotations**: Annotations provided by the JUnit testing framework for defining and controlling test cases and test execution. JUnit annotations include `@Test`, `@Before`, `@After`, `@BeforeClass`, `@AfterClass`, `@Ignore`, and others used for writing and running unit tests in Java.

These are some of the key terminologies and concepts associated with Java annotations, which are essential for understanding and using annotations effectively in Java programming for metadata-driven configurations, frameworks, and libraries.


### Nodejs terminologies and buzz words

Certainly! Node.js is a popular runtime environment for executing JavaScript code outside the web browser, typically on the server-side. Here are some key terminologies and buzzwords associated with Node.js:

1. **Node.js**: An open-source, cross-platform JavaScript runtime environment built on Chrome's V8 JavaScript engine. Node.js enables developers to run JavaScript code outside the browser, allowing for server-side programming, networking, and file system operations.

2. **Event-Driven Architecture**: A programming paradigm used in Node.js to handle I/O operations asynchronously and efficiently. Node.js uses an event loop and event-driven model to process requests and events non-blocking manner, allowing for high concurrency and scalability.

3. **Non-blocking I/O**: A programming model used in Node.js to perform I/O operations asynchronously without blocking the execution of other code. Node.js uses non-blocking I/O APIs and event-driven architecture to handle I/O operations concurrently, improving performance and scalability.

4. **Callback Function**: A function passed as an argument to another function and invoked asynchronously to handle the result of an asynchronous operation or event. Callback functions are commonly used in Node.js for handling I/O operations, event handling, and asynchronous tasks.

5. **Package Manager**: A tool used to manage dependencies, libraries, and packages in Node.js projects. npm (Node Package Manager) is the default package manager for Node.js, providing commands for installing, updating, and removing packages from project dependencies.

6. **npm (Node Package Manager)**: The default package manager for Node.js, used to install, manage, and publish packages and dependencies for Node.js projects. npm provides a vast repository of open-source packages and libraries for various purposes, including web development, utilities, frameworks, and tools.

7. **Module**: A reusable piece of code or library encapsulated within a file or directory in Node.js. Node.js modules can be imported and exported using the `require()` and `module.exports` or `export` keywords, allowing for modular and maintainable code organization.

8. **CommonJS**: A module system used in Node.js for defining and importing modules using the `require()` function and exporting modules using the `module.exports` object. CommonJS modules are synchronous and commonly used in Node.js for server-side JavaScript development.

9. **ECMAScript Modules (ESM)**: A standardized module system introduced in ECMAScript 6 (ES6) for defining and importing modules using `import` and `export` keywords. Node.js supports ESM modules with the `.mjs` file extension and experimental support for `.js` files using `--experimental-modules` flag.

10. **Express.js**: A minimalist web application framework for Node.js used for building web servers and APIs. Express.js provides a robust set of features and middleware for routing, request handling, middleware composition, and HTTP utility methods, making it popular for building web applications in Node.js.

11. **Middleware**: Functions or modules used in Express.js to process HTTP requests and responses in the request-response cycle. Express middleware functions can modify request and response objects, execute additional logic, and pass control to the next middleware in the chain.

12. **RESTful API**: A style of web API architecture based on Representational State Transfer (REST) principles for designing scalable and interoperable web services. Node.js is commonly used for building RESTful APIs using frameworks like Express.js and libraries like `express.Router()` for routing and resource handling.

13. **WebSocket**: A communication protocol that provides full-duplex communication channels over a single TCP connection, allowing for real-time, bidirectional data transfer between clients and servers. Node.js supports WebSocket communication using libraries like `ws` and frameworks like Socket.io.

14. **Asynchronous Module Definition (AMD)**: A module system and specification for defining and loading modules asynchronously in JavaScript environments, commonly used in client-side web development. Node.js does not natively support AMD modules but can be used with AMD-compatible loaders like RequireJS.

15. **Cluster**: A module in Node.js used for managing multiple instances of a Node.js process to take advantage of multi-core CPU architectures and improve application performance and scalability. Node.js clusters enable parallel processing and load balancing of incoming requests across multiple workers.

These are some of the key terminologies and concepts associated with Node.js, which are essential for understanding and developing applications using Node.js runtime environment and JavaScript ecosystem.


### PUG (formerly known as Jade) terminologies and buzz words

Ah, I see! In the context of Node.js, "PUB" likely refers to the popular template engine called Pug (formerly known as Jade). Pug is a templating engine for Node.js and browsers that allows you to write HTML markup in a concise and expressive manner using indentation and mixins. Here are some terminologies and buzzwords associated with Pug:

1. **Template Engine**: A software component that allows you to generate dynamic HTML content by combining static markup with dynamic data. Template engines like Pug enable developers to write HTML templates with placeholders for variables and logic.

2. **HTML Templating**: The process of creating HTML templates that can be dynamically populated with data from a server or application. HTML templating engines like Pug simplify the process of generating HTML content by providing syntax for placeholders, loops, conditionals, and includes.

3. **Syntax**: The specific rules and conventions used to write markup and code in the Pug template language. Pug syntax is indentation-based, with support for mixins, interpolation, attributes, conditionals, loops, and more.

4. **Indentation-based Syntax**: Pug uses indentation to define the structure and hierarchy of HTML elements, eliminating the need for closing tags and reducing visual clutter in template files.

5. **Mixins**: Reusable code snippets or functions defined in Pug templates that can be included and invoked multiple times within the same or different templates. Mixins help to encapsulate and reuse common HTML patterns or components.

6. **Interpolation**: The process of embedding dynamic values or expressions within Pug templates using interpolation syntax. Variables, JavaScript expressions, and function calls can be interpolated within Pug templates using the `#{}` syntax.

7. **Attributes**: HTML attributes can be specified inline or using shorthand syntax in Pug templates, allowing for the dynamic generation of attribute values based on data or logic.

8. **Conditionals**: Pug supports conditional rendering of HTML elements based on boolean expressions or data values using the `if`, `else if`, and `else` keywords.

9. **Loops**: Pug provides syntax for iterating over arrays or collections and generating repetitive HTML content using loop constructs such as `each` and `for`.

10. **Include**: Pug allows you to include and import external template files or partials into main template files using the `include` keyword, enabling modularization and code reuse.

11. **Extends and Blocks**: Pug supports template inheritance through the `extends` and `block` keywords, allowing you to create base templates with placeholder blocks that can be overridden by child templates.

12. **Filters**: Pug provides built-in filters for processing and transforming text content within templates, such as Markdown, CoffeeScript, and Sass filters.

13. **Client-side Compilation**: Pug templates can be compiled and rendered on the client-side using JavaScript libraries like Pug.js, allowing for dynamic rendering of HTML content in web browsers.

14. **Express.js Integration**: Pug is commonly used with the Express.js web framework for Node.js, providing seamless integration and support for rendering Pug templates in Express.js applications.

15. **Performance**: Pug is known for its performance and efficiency, with features like template caching, precompilation, and minimal runtime overhead for rendering dynamic HTML content.

These are some of the key terminologies and concepts associated with Pug, the template engine used with Node.js for generating dynamic HTML content in web applications and server-side rendering.

#### Please write few alternatives for Pug

Certainly! While Pug (formerly known as Jade) is a popular choice for templating in Node.js applications, there are several alternatives available. Here are a few alternatives to Pug:

1. **EJS (Embedded JavaScript)**: EJS is a simple templating language that lets you generate HTML markup with plain JavaScript embedded within `<% %>` tags. It is widely used and offers a familiar syntax for developers comfortable with JavaScript.

2. **Handlebars**: Handlebars is a popular templating engine that provides a logic-less template syntax with support for expressions, helpers, partials, and block expressions. It emphasizes simplicity, performance, and flexibility.

3. **Mustache**: Mustache is a logic-less template system available in multiple programming languages, including JavaScript. It offers a simple and intuitive syntax for generating HTML markup with placeholders that are replaced with data at runtime.

4. **Nunjucks**: Nunjucks is a powerful templating engine inspired by Jinja2 (Python) and Twig (PHP). It provides features like template inheritance, macros, filters, and asynchronous rendering, making it suitable for building complex web applications.

5. **Twig.js**: Twig.js is a JavaScript implementation of the Twig templating language, originally developed for PHP. It offers a concise and expressive syntax with support for template inheritance, block tags, filters, and internationalization.

6. **React**: React is a JavaScript library for building user interfaces, but it can also be used for server-side rendering (SSR) with libraries like ReactDOMServer. JSX syntax allows you to write HTML-like markup directly in JavaScript files, offering component-based templating and reusability.

7. **Nunjucks**: Another great choice, built on top of Jinja2 (Python) and Twig (PHP), offering template inheritance, block tags, filters, and more.

8. **Handlebars**: A logic-less templating engine that focuses on semantic templates and an easy-to-understand syntax. It supports partials, helpers, and precompilation, making it suitable for building dynamic web applications.

9. **Marko**: A fast, lightweight, and intuitive templating engine developed by eBay. It offers a syntax that closely resembles HTML, along with features like custom tags, reusable components, and server-side rendering.

10. **Swig**: A robust, feature-rich templating engine inspired by Django's template syntax. It provides support for template inheritance, filters, loops, and conditionals, making it suitable for building dynamic web applications.

These are just a few alternatives to Pug, each with its own syntax, features, and strengths. The choice of templating engine depends on factors such as personal preference, project requirements, familiarity with the syntax, and ecosystem compatibility.

### EJS terminologies and buzz words

Certainly! EJS (Embedded JavaScript) is a simple templating language that lets you generate HTML markup with plain JavaScript embedded within `<% %>` tags. Here are some key terminologies and buzzwords associated with EJS:

1. **Template Engine**: A software component that allows you to generate dynamic HTML content by combining static markup with dynamic data. EJS is a template engine for JavaScript that enables developers to embed JavaScript code directly within HTML templates.

2. **Embedded JavaScript (EJS)**: The name of the templating language and file extension used for EJS templates. EJS templates typically have the `.ejs` file extension and contain HTML markup with embedded JavaScript code enclosed within `<% %>` tags.

3. **Interpolation**: The process of embedding dynamic values or expressions within EJS templates using interpolation syntax. Variables, JavaScript expressions, and function calls can be interpolated within EJS templates using the `<%= %>` syntax.

4. **Scriptlet**: A block of JavaScript code embedded within EJS templates using scriptlet tags `<% %>` without any output or interpolation. Scriptlets are used for executing logic, control flow statements, and function definitions within EJS templates.

5. **Expression**: A JavaScript expression enclosed within `<%= %>` tags that is evaluated and inserted into the HTML output of the EJS template. Expressions can include variables, function calls, arithmetic operations, and conditional expressions.

6. **Partial**: A reusable fragment of HTML or EJS code that can be included and rendered within multiple EJS templates. Partials allow for code reuse and modularization of template components, improving maintainability and readability of EJS templates.

7. **Layout**: A master template or layout file that defines the overall structure, layout, and common elements of multiple EJS templates. Layouts typically include placeholders for dynamic content and partials, allowing for consistent styling and design across pages.

8. **Control Flow**: The execution of JavaScript code based on conditional expressions, loops, and control statements within EJS templates. EJS provides syntax for control flow constructs such as `if`, `else`, `for`, `while`, and `switch` statements for dynamic content generation.

9. **Escaping**: The process of converting special characters and HTML entities into their corresponding HTML escape sequences to prevent XSS (Cross-Site Scripting) attacks and maintain HTML validity. EJS automatically escapes HTML output by default, but you can disable escaping using `<%- %>` tags.

10. **Delimiter**: The characters used to delimit JavaScript code blocks, expressions, and scriptlets within EJS templates. EJS supports configurable delimiters, allowing you to customize the opening and closing tags for scriptlets (`<% %>`) and expressions (`<%= %>`) as needed.

11. **Rendering**: The process of compiling and executing EJS templates to generate HTML output dynamically based on the provided data and logic. EJS templates are rendered on the server-side or client-side using JavaScript runtime environments like Node.js.

12. **Layout Engine**: The component responsible for parsing, compiling, and rendering EJS templates to generate HTML output. EJS templates are processed by the EJS layout engine, which evaluates embedded JavaScript code and interpolates dynamic values to produce the final HTML content.

13. **Partial Rendering**: The process of rendering and including partials within EJS templates to compose complex views and user interfaces from smaller, reusable components. Partial rendering allows for modularization and encapsulation of UI components, promoting code reusability and maintainability.

14. **Dynamic Content**: Content within EJS templates that is generated or modified dynamically based on data, user input, or application logic. EJS templates support dynamic content generation using JavaScript code, expressions, and variables embedded within the template markup.

15. **Client-side Rendering**: The process of rendering EJS templates on the client-side using JavaScript frameworks or libraries like Angular, React, or Vue.js. EJS templates can be precompiled or rendered dynamically in the browser to generate HTML content dynamically on the client-side.

These are some of the key terminologies and concepts associated with EJS, the Embedded JavaScript templating language used for generating dynamic HTML content in web applications and server-side rendering with Node.js.


### Angular terminologies and buzz words

Certainly! Here are some key terminologies and buzzwords associated with Angular:

1. **Angular**: Angular is a popular open-source web application framework maintained by Google and a community of developers. It is used for building dynamic single-page web applications (SPAs) and progressive web applications (PWAs).

2. **Component-based Architecture**: Angular follows a component-based architecture where the UI is built using reusable and composable components. Each component encapsulates its own logic, template, and styling, making it easier to maintain and scale applications.

3. **Module**: An Angular module is a mechanism for organizing the application into cohesive blocks of functionality. Modules can contain components, services, directives, and other Angular constructs. Angular applications typically have at least one root module (AppModule) and may have additional feature modules for organizing related functionality.

4. **Component**: A building block of Angular applications, a component is a TypeScript class that defines the behavior and properties of a UI element. Components have associated templates (HTML markup) for rendering the UI and styles (CSS) for styling the UI elements.

5. **Template**: An HTML markup associated with an Angular component that defines the structure of the UI. Angular templates can include data bindings, directives, interpolation, and event bindings to interact with component logic and data.

6. **Data Binding**: Data binding is a mechanism for synchronizing data between the component class and its template. Angular supports one-way data binding (from component to template), two-way data binding (both component to template and template to component), and event binding (from template to component).

7. **Directive**: Directives are markers on a DOM element that tell Angular to attach a specific behavior or functionality to that element. Angular provides built-in directives like ngIf, ngFor, and ngModel, as well as the ability to create custom directives for extending HTML functionality.

8. **Service**: Angular services are reusable singleton objects that encapsulate business logic, data manipulation, or communication with external services. Services are typically injected into components or other services using Angular's dependency injection mechanism.

9. **Dependency Injection (DI)**: Dependency injection is a design pattern used in Angular for managing dependencies between components and services. Angular's DI system allows you to declare dependencies in the constructor of a component or service and have them provided automatically by the Angular injector.

10. **Router**: The Angular Router is a powerful tool for managing navigation and routing in Angular applications. It allows you to define routes, associate them with components, and handle navigation between different views or pages within the application.

11. **HTTP Client**: Angular provides an HttpClient module for making HTTP requests to remote servers or APIs. It offers features like request and response interception, error handling, and observables-based API for handling asynchronous data.

12. **Observables**: Observables are a key feature of Angular's reactive programming paradigm, based on the RxJS library. Observables represent streams of data that can be observed and manipulated asynchronously, enabling reactive and event-driven programming in Angular applications.

13. **Forms**: Angular provides support for both template-driven forms and reactive forms for handling user input and validation. Template-driven forms use directives and two-way data binding, while reactive forms use reactive programming and a model-driven approach for managing form data and validation.

14. **Lifecycle Hooks**: Angular components have a lifecycle with various stages such as creation, initialization, rendering, and destruction. Angular provides lifecycle hooks like ngOnInit, ngOnDestroy, ngOnChanges, etc., for executing custom logic at different stages of a component's lifecycle.

15. **NgModule**: Angular modules (NgModule) are used to organize the application into cohesive units of functionality. They can contain components, directives, pipes, and services, and help in lazy loading and optimizing the application's performance.

These are some of the key terminologies and concepts associated with Angular, which are essential for understanding and developing applications using the Angular framework.


### spring boot JPA terminologies and buzz words

Certainly! Here are some key terminologies and buzzwords associated with Spring Boot and JPA (Java Persistence API):

1. **Spring Boot**: Spring Boot is a popular open-source Java framework used for building stand-alone, production-grade Spring-based applications. It provides a streamlined development experience by offering auto-configuration, embedded servers, and opinionated defaults.

2. **JPA (Java Persistence API)**: JPA is a Java specification for accessing, managing, and persisting data between Java objects and relational databases. It provides a high-level abstraction over database operations and simplifies the development of data access layers in Java applications.

3. **Entity**: In JPA, an entity is a Java class that represents a persistent data entity mapped to a database table. Entities typically correspond to database records and contain fields (properties) that map to table columns.

4. **Repository**: A repository in Spring Data JPA is an interface that provides CRUD (Create, Read, Update, Delete) operations for managing entities. Repositories extend the JpaRepository interface or its subinterfaces, which offer methods for common database operations.

5. **EntityManager**: The EntityManager is a core interface in JPA used for managing entity instances and performing database operations. It provides methods for persisting, retrieving, updating, and deleting entities, as well as querying the database using JPQL (Java Persistence Query Language).

6. **Persistence Context**: The Persistence Context is a cache-like environment managed by the EntityManager that stores managed entity instances during the lifecycle of a transaction. It tracks changes to entities and synchronizes them with the database upon transaction commit.

7. **Primary Key (ID)**: In database terminology, a primary key is a unique identifier for each record in a table. In JPA entities, the primary key is typically represented by a field annotated with the @Id annotation.

8. **Entity Manager Factory**: The EntityManagerFactory is a factory class responsible for creating EntityManager instances. It is typically configured with persistence unit information and database connection settings.

9. **DTO (Data Transfer Object)**: DTOs are Java objects used for transferring data between different layers of an application, such as between the presentation layer and the service layer. In Spring Boot JPA applications, DTOs are often used to encapsulate data retrieved from entities and passed to the presentation layer.

10. **JPQL (Java Persistence Query Language)**: JPQL is a query language used to perform database queries in JPA applications. It is similar to SQL (Structured Query Language) but operates on entity objects rather than database tables. JPQL queries are defined using entity and field names rather than table and column names.

11. **Criteria API**: The Criteria API is a programmatic API in JPA for building dynamic, type-safe queries using Java code. It allows developers to construct query criteria and conditions using a fluent API, making queries more readable and maintainable.

12. **Cascade Type**: Cascade type is an attribute of JPA associations (such as @OneToMany and @ManyToOne) that specifies how entity lifecycle operations (such as persist, merge, remove) should be cascaded from parent entities to associated child entities.

13. **Lazy Loading**: Lazy loading is a fetching strategy in JPA where associated entities are loaded from the database only when accessed for the first time. This helps reduce memory usage and improve performance by avoiding unnecessary database queries.

14. **Auditing**: Auditing is a feature in Spring Data JPA that automatically tracks and records changes to entity objects, such as creation time, modification time, and the user who made the changes. Auditing is commonly used for implementing audit trails and versioning in database applications.

15. **Optimistic Locking**: Optimistic locking is a concurrency control mechanism in JPA where multiple transactions are allowed to access and modify the same data concurrently. It relies on versioning or timestamping to detect and prevent conflicting updates during transaction commits.

These are some of the key terminologies and concepts associated with Spring Boot and JPA, which are essential for understanding and developing data access layers in Java applications using the Spring framework.


### Spring boot security terminologies and buzz words

Certainly! Here are some key terminologies and buzzwords associated with Spring Boot Security:

1. **Spring Security**: Spring Security is a powerful and customizable authentication and access control framework for securing Java-based applications. It provides comprehensive security features such as authentication, authorization, session management, and protection against common security vulnerabilities.

2. **Authentication**: Authentication is the process of verifying the identity of a user or entity accessing an application. Spring Security supports various authentication mechanisms, including form-based authentication, HTTP basic authentication, OAuth, and LDAP authentication.

3. **Authorization**: Authorization is the process of determining whether an authenticated user has permission to access a particular resource or perform a specific operation within the application. Spring Security supports role-based access control (RBAC), expression-based access control, and method-level security.

4. **Principal**: In Spring Security, a Principal represents the currently authenticated user or entity accessing the application. Principals encapsulate information about the user's identity, such as username, authorities, and additional attributes.

5. **Granted Authority**: A Granted Authority represents a permission or role granted to a user or entity within the application. Authorities are typically used for defining access control rules and determining whether a user has permission to perform certain actions.

6. **UserDetailsService**: The UserDetailsService interface is used in Spring Security for retrieving user details (such as username, password, and authorities) from a data source, such as a database or LDAP directory. It is responsible for loading user information during authentication.

7. **PasswordEncoder**: The PasswordEncoder interface is used in Spring Security for encrypting and validating passwords stored in the application's database or user repository. It provides secure hashing algorithms (such as BCrypt, SCrypt, or SHA) for protecting user passwords against unauthorized access.

8. **AuthenticationProvider**: An AuthenticationProvider is a strategy interface in Spring Security for authenticating users based on their credentials. It is responsible for performing authentication logic, such as verifying passwords, validating tokens, or integrating with external authentication providers.

9. **SecurityContext**: The SecurityContext is a thread-local container in Spring Security that holds the security-related information associated with the current user's session. It includes details such as the authenticated principal, authentication status, and granted authorities.

10. **FilterChain**: A FilterChain is a series of filters in Spring Security that intercept and process incoming HTTP requests before they reach the application's endpoints. Filters are responsible for performing security checks, authentication, authorization, and other security-related tasks.

11. **CSRF Protection**: Cross-Site Request Forgery (CSRF) protection is a security feature in Spring Security that prevents unauthorized users from submitting malicious requests on behalf of authenticated users. Spring Security provides built-in CSRF protection mechanisms, such as CSRF tokens and CSRF filters.

12. **Session Management**: Session management is the process of managing user sessions and maintaining session state securely in web applications. Spring Security offers features for controlling session creation, tracking session activity, and implementing session fixation protection.

13. **Remember Me Authentication**: Remember Me authentication is a feature in Spring Security that allows users to authenticate once and be remembered across multiple sessions without re-entering their credentials. It relies on persistent tokens or cookies to automatically authenticate users upon subsequent visits.

14. **Access Control List (ACL)**: Access Control Lists (ACLs) are security mechanisms used in Spring Security for fine-grained access control at the domain object level. ACLs define permissions and restrictions on individual domain objects, allowing for complex authorization rules based on object ownership, roles, and permissions.

15. **OAuth**: OAuth is an open standard for authorization that allows users to grant third-party applications limited access to their resources without sharing their credentials. Spring Security provides support for OAuth 2.0, enabling secure authentication and authorization in distributed systems and APIs.

These are some of the key terminologies and concepts associated with Spring Boot Security, which are essential for understanding and implementing robust security features in Java-based applications using the Spring framework.


### Maven terminologies and buzz words

Certainly! Here are some key terminologies and buzzwords associated with Maven:

1. **Maven**: Maven is a powerful build automation tool used primarily for Java projects. It provides a standardized way to manage project dependencies, build processes, and project lifecycle management.

2. **POM (Project Object Model)**: The POM is an XML file that contains configuration information and metadata for a Maven project. It defines project settings, dependencies, plugins, and build profiles.

3. **Artifact**: An artifact is a file generated by Maven during the build process. It can be a JAR (Java Archive), WAR (Web Archive), EAR (Enterprise Archive), or any other type of file produced by the project build.

4. **Dependency**: A dependency is a library or module that a Maven project relies on to build and run successfully. Dependencies are defined in the POM file and automatically downloaded from remote repositories by Maven.

5. **Repository**: A repository is a location where Maven stores project dependencies and artifacts. Maven supports two types of repositories: local repositories (stored on the developer's machine) and remote repositories (hosted on a server and accessed over the internet).

6. **Plugin**: A plugin is a software component that extends Maven's functionality by providing additional goals and tasks for the build process. Plugins are configured in the POM file and can perform various tasks such as compiling code, running tests, packaging artifacts, and deploying applications.

7. **Lifecycle**: The Maven lifecycle defines a series of phases that represent the stages of the project build process. Each phase is associated with a set of goals, which are executed sequentially to perform tasks such as compilation, testing, packaging, and deployment.

8. **Goal**: A goal is a specific task or operation performed by a Maven plugin during the build process. Goals are bound to specific phases of the build lifecycle and are executed in a predefined order.

9. **Build Profile**: A build profile is a set of configuration settings that can be activated or deactivated based on certain conditions or environments. Profiles allow developers to customize the build process for different scenarios, such as development, testing, or production.

10. **Transitive Dependency**: A transitive dependency is a dependency of a project's direct dependency. When Maven resolves dependencies, it automatically includes transitive dependencies to ensure that all required libraries are available for the project.

11. **SNAPSHOT**: In Maven, a SNAPSHOT version indicates that the artifact is under active development and subject to frequent changes. SNAPSHOT versions are typically used for development and testing purposes and may not be stable or suitable for production use.

12. **Repository Manager**: A repository manager is a server application used to manage and host repositories of Maven artifacts. Popular repository managers include Nexus, Artifactory, and Apache Archiva.

13. **Dependency Management**: Dependency management is the process of managing project dependencies and ensuring that the correct versions of libraries are used throughout the project. Maven's dependency management features simplify the process of resolving and managing dependencies.

14. **Parent POM**: A parent POM is an XML file that contains common configuration settings and dependencies shared by multiple Maven projects. It allows developers to centralize project configuration and enforce consistency across related projects.

15. **Maven Coordinates**: Maven coordinates, also known as GAV coordinates, uniquely identify a Maven artifact within a repository. GAV stands for Group ID, Artifact ID, and Version, which together specify the artifact's group, name, and version.

These are some of the key terminologies and concepts associated with Maven, which are essential for understanding and effectively using Maven for building and managing Java projects.


### Apache Ant terminologies and buzz words

Certainly! Here are some key terminologies and buzzwords associated with Apache Ant:

1. **Ant**: Apache Ant is a popular open-source build automation tool used primarily for Java projects. It is similar to Apache Maven but uses XML-based configuration files (build.xml) instead of POM files for defining build processes and tasks.

2. **Build.xml**: The build.xml file is the main configuration file used by Apache Ant to define build targets, tasks, dependencies, and other build-related settings. It is written in XML and contains instructions for building, testing, packaging, and deploying the project.

3. **Task**: A task is a unit of work or operation performed by Apache Ant during the build process. Tasks are defined in the build.xml file using XML elements and attributes, and they can perform various actions such as compiling code, copying files, running tests, and generating documentation.

4. **Target**: A target is a collection of tasks that represent a specific build goal or action in Apache Ant. Targets are defined in the build.xml file and can depend on other targets, allowing for sequential execution of tasks and modularization of the build process.

5. **Dependency**: A dependency is a file or resource required by a task or target in Apache Ant. Dependencies can be specified using <classpath>, <fileset>, or <path> elements in the build.xml file to include libraries, source files, configuration files, or other resources needed for the build.

6. **Property**: A property is a named value or variable used to store configuration settings, file paths, or other data in Apache Ant. Properties can be defined in the build.xml file using <property> elements and referenced by tasks and targets to parameterize the build process.

7. **Taskdef**: The taskdef task is used in Apache Ant to define custom tasks or extend the functionality of Ant by loading external task definitions from Java classes or JAR files. It allows developers to create reusable custom tasks to automate specific build tasks.

8. **Antlib**: An Antlib is a library of reusable tasks and types packaged as a JAR file and designed for use with Apache Ant. Antlibs can contain custom tasks, types, and resources that extend the functionality of Ant and provide additional capabilities for building and managing projects.

9. **Fileset**: A fileset is a collection of files or directories specified by patterns and used as input to tasks in Apache Ant. Filesets are defined using <fileset> elements in the build.xml file and allow developers to specify sets of files to include or exclude from a task's operation.

10. **Filter**: A filter is a mechanism in Apache Ant for processing and modifying text files or resources during the build process. Filters can be applied to files using the <filter> task and are commonly used for performing text replacement, token substitution, or property expansion.

11. **Condition**: A condition is a test or evaluation performed by Apache Ant to determine whether a task or target should be executed based on certain criteria. Conditions can be specified using <condition> elements in the build.xml file and are used to control the flow of the build process.

12. **Macrodef**: The macrodef task is used in Apache Ant to define reusable macro tasks or parameterized sequences of tasks. Macrodefs allow developers to encapsulate common build logic into reusable components and simplify the build.xml file by reducing duplication.

13. **Resource Collection**: A resource collection is a set of files, directories, or other resources specified by patterns and used as input to tasks in Apache Ant. Resource collections are defined using <resources> elements and can be combined, filtered, or modified to suit the needs of the build process.

14. **Selector**: A selector is a mechanism in Apache Ant for selecting files or resources based on specific criteria such as file attributes, patterns, or conditions. Selectors can be used to include or exclude files from tasks like copying, archiving, or deleting files during the build process.

15. **Extension Point**: An extension point is a predefined hook or marker in Apache Ant that allows developers to inject custom behavior or tasks into the build process. Extension points provide flexibility for extending and customizing the build.xml file with additional functionality or logic.

These are some of the key terminologies and concepts associated with Apache Ant, which are essential for understanding and effectively using Ant for automating build processes and managing Java projects.



### Gradle terminologies and buzz words

Certainly! Here are some key terminologies and buzzwords associated with Gradle:

1. **Gradle**: Gradle is a powerful build automation tool and dependency management system used primarily for Java, Groovy, and Kotlin projects. It uses a Groovy-based domain-specific language (DSL) or Kotlin DSL for defining build scripts and tasks.

2. **Build Script**: A build script is a Groovy or Kotlin script written in Gradle's DSL that defines the configuration, tasks, dependencies, and build logic for a project. Build scripts are typically named build.gradle and are located in the project's root directory.

3. **Task**: A task is a unit of work or operation performed by Gradle during the build process. Tasks are defined in the build script and can perform various actions such as compiling code, running tests, packaging artifacts, and deploying applications.

4. **Project**: A project is a logical unit of organization in Gradle that represents a software project or module. Projects can have dependencies, configurations, tasks, and other settings defined in their build scripts.

5. **Dependency**: A dependency is a library or module required by a project to build and run successfully. Dependencies are declared in the build script and automatically downloaded from remote repositories by Gradle.

6. **Plugin**: A plugin is a software component that extends Gradle's functionality by providing additional tasks, configurations, and capabilities for the build process. Gradle supports a wide range of plugins for various purposes, including Java, Groovy, Kotlin, Android, and more.

7. **Configuration**: A configuration is a named set of dependencies and settings used by Gradle to resolve dependencies, compile code, and perform other build tasks. Gradle provides predefined configurations such as compile, runtime, testCompile, and testRuntime, which define different scopes for dependencies.

8. **Repository**: A repository is a location where Gradle stores project dependencies and artifacts. Gradle supports two types of repositories: local repositories (stored on the developer's machine) and remote repositories (hosted on a server and accessed over the internet).

9. **Build Lifecycle**: The build lifecycle in Gradle defines a series of phases or stages that represent the stages of the project build process. Each phase is associated with a set of tasks and dependencies that are executed sequentially to perform the build.

10. **Convention over Configuration**: Gradle follows the convention over configuration principle, which means that it provides sensible defaults and conventions for project configuration and build settings. This allows developers to focus on writing code rather than configuring build scripts.

11. **Multi-Project Build**: Gradle supports multi-project builds, where multiple projects or modules are organized into a hierarchical structure and built together as a single unit. Multi-project builds allow for better code reuse, dependency management, and modularization of large-scale projects.

12. **Incremental Build**: Gradle's incremental build feature allows it to recompile, test, and package only the parts of the project that have changed since the last build. This helps improve build performance and reduces build times by avoiding unnecessary re-execution of tasks.

13. **Gradle Wrapper**: The Gradle Wrapper is a tool provided by Gradle for generating and distributing a standalone script (gradlew or gradlew.bat) that can automatically download and install the correct version of Gradle for the project. The wrapper ensures that all developers use the same version of Gradle and simplifies project setup and distribution.

14. **Custom Task**: Gradle allows developers to define custom tasks in the build script using Groovy or Kotlin. Custom tasks can perform any arbitrary action or operation required for the build process and can be integrated into the build lifecycle as needed.

15. **Build Cache**: Gradle's build cache feature allows it to cache task outputs and build artifacts between builds. This helps improve build performance by avoiding redundant work and reusing previously cached results when possible.

These are some of the key terminologies and concepts associated with Gradle, which are essential for understanding and effectively using Gradle for building and managing software projects.